{
  "meta": {
    "title": "TS Quest",
    "subtitle": "Тренировка TypeScript в стиле Duolingo",
    "locale": "ru-RU",
    "version": "1.1.0",
    "author": "codex"
  },
  "units": [
    {
      "id": "unit-intro",
      "title": "Введение и общее",
      "description": "Введение в TypeScript: зачем он нужен и как работает статическая типизация.",
      "accent": "#0EA5A4",
      "levels": [
        {
          "id": "lvl-intro-basics",
          "title": "Зачем нужен TypeScript?",
          "goal": "Понять преимущества TypeScript и его отличия от JavaScript.",
          "steps": [
            {
              "id": "intro-basics-1",
              "type": "choice",
              "prompt": "Что такое TypeScript?",
              "options": [
                "Язык программирования, расширяющий JavaScript статической типизацией.",
                "Новый язык программирования, не основанный на JavaScript.",
                "Библиотека JavaScript для типизации.",
                "Среда выполнения для JavaScript-кода."
              ],
              "answer": "Язык программирования, расширяющий JavaScript статической типизацией.",
              "xp": 10,
              "tip": "TypeScript не переписывает JavaScript заново, а добавляет к нему статическую типизацию."
            },
            {
              "id": "intro-basics-2",
              "type": "fill",
              "prompt": "TypeScript — это _ JavaScript, добавляющий статическую типизацию.",
              "placeholder": "определение",
              "answers": [
                "надмножество",
                "надстройка над",
                "расширение"
              ],
              "xp": 10,
              "tip": "TypeScript — не отдельный язык, а расширяет возможности JavaScript."
            },
            {
              "id": "intro-basics-3",
              "type": "choice",
              "prompt": "Какое из этих утверждений описывает преимущество TypeScript?",
              "options": [
                "Обнаруживает многие ошибки еще до запуска программы.",
                "Ускоряет выполнение JavaScript-кода в браузере.",
                "Автоматически тестирует код вместо разработчика.",
                "Исключает необходимость в JavaScript."
              ],
              "answer": "Обнаруживает многие ошибки еще до запуска программы.",
              "xp": 10,
              "tip": "Статическая типизация позволяет ловить ошибки на этапе компиляции, еще до запуска."
            },
            {
              "id": "intro-basics-4",
              "type": "select-line",
              "prompt": "На какой строке возникает ошибка типизации?",
              "lines": [
                "function add(a: number, b: number) {",
                " return a + b;",
                "}",
                "const result = add('5', 10);",
                "console.log(result);"
              ],
              "answerLine": 4,
              "xp": 12,
              "tip": "Проверь вызов функции: аргументы должны соответствовать объявленным типам.",
              "explanation": "Функция add ожидает аргумент a как number, но передана строка."
            },
            {
              "id": "intro-basics-5",
              "type": "match",
              "prompt": "Сопоставь понятие TypeScript с его описанием.",
              "left": [
                "Статическая типизация",
                "Компиляция",
                "Вывод типов",
                "Аннотация типа"
              ],
              "right": [
                "Проверка типов во время компиляции",
                "Преобразование TS-кода в JS-код",
                "Определение типа переменной на основе значения",
                "Явное указание типа переменной"
              ],
              "pairs": [
                {
                  "left": "Статическая типизация",
                  "right": "Проверка типов во время компиляции"
                },
                {
                  "left": "Компиляция",
                  "right": "Преобразование TS-кода в JS-код"
                },
                {
                  "left": "Вывод типов",
                  "right": "Определение типа переменной на основе значения"
                },
                {
                  "left": "Аннотация типа",
                  "right": "Явное указание типа переменной"
                }
              ],
              "xp": 14,
              "tip": "TypeScript сам может определить тип (вывод типов) или принять указанный явно (аннотация). Статическая типизация – основа TS, а компиляция превращает код в JavaScript."
            },
            {
              "id": "intro-basics-6",
              "type": "choice",
              "prompt": "С каким расширением сохраняются файлы с кодом TypeScript?",
              "options": [
                ".ts",
                ".js",
                ".jsx",
                ".java"
              ],
              "answer": ".ts",
              "xp": 10,
              "tip": "Подсказка: расширение – это сокращение от названия TypeScript."
            },
            {
              "id": "intro-basics-7",
              "type": "choice",
              "prompt": "Как называется утилита для компиляции TypeScript-кода в JavaScript?",
              "options": [
                "tsc",
                "npm",
                "babel",
                "node"
              ],
              "answer": "tsc",
              "xp": 10,
              "tip": "Компилятор TypeScript – это отдельная программа, обычно вызываемая из консоли."
            },
            {
              "id": "intro-basics-8",
              "type": "fill",
              "prompt": "TypeScript проверяет типы во время .",
              "placeholder": "когда?",
              "answers": [
                "компиляции"
              ],
              "xp": 10,
              "tip": "JavaScript-код проверяется только во время выполнения, а TypeScript – до запуска."
            },
            {
              "id": "intro-basics-9",
              "type": "choice",
              "prompt": "Что необходимо сделать перед запуском кода TypeScript?",
              "options": [
                "Скомпилировать его в JavaScript",
                "Просто открыть файл .ts в браузере",
                "Запустить файл .ts с помощью Node.js напрямую",
                "Ничего, современные браузеры понимают TypeScript"
              ],
              "answer": "Скомпилировать его в JavaScript",
              "xp": 10,
              "tip": "TypeScript не выполняется нативно: его нужно превратить в обычный JS."
            },
            {
              "id": "intro-basics-10",
              "type": "choice",
              "prompt": "Синтаксис TypeScript более всего похож на синтаксис:",
              "options": [
                "JavaScript",
                "Java",
                "Python",
                "C#"
              ],
              "answer": "JavaScript",
              "xp": 10,
              "tip": "TypeScript сохраняет синтаксис JavaScript и дополняет его типами."
            },
            {
              "id": "intro-basics-11",
              "type": "order",
              "prompt": "Упорядочи этапы работы с TypeScript-кодом:",
              "tokens": [
                "написать код на TS",
                "скомпилировать в JS",
                "получить файл .js",
                "запустить файл .js"
              ],
              "solution": [
                "написать код на TS",
                "скомпилировать в JS",
                "получить файл .js",
                "запустить файл .js"
              ],
              "xp": 12,
              "tip": "Вспомни, что браузеры выполняют только JavaScript."
            }
          ]
        },
        {
          "id": "lvl-intro-typing",
          "title": "Аннотации типов и вывод",
          "goal": "Научиться задавать типы явно и понимать вывод типов.",
          "steps": [
            {
              "id": "intro-typing-1",
              "type": "choice",
              "prompt": "Какой тип выведет TypeScript для переменной const age = 21?",
              "options": [
                "string",
                "number",
                "boolean",
                "any"
              ],
              "answer": "number",
              "xp": 10,
              "tip": "TypeScript выводит тип из присвоенного значения. Числовой литерал без as const получит тип number."
            },
            {
              "id": "intro-typing-2",
              "type": "choice",
              "prompt": "Какой тип возвращаемого значения выведется для функции:\nts\nfunction greet(name: string) {\n return 'Hello, ' + name;\n}\n",
              "options": [
                "string",
                "void",
                "any",
                "number"
              ],
              "answer": "string",
              "xp": 10,
              "tip": "TypeScript определяет возвращаемый тип из типа значения, которое возвращается (после return)."
            },
            {
              "id": "intro-typing-3",
              "type": "match",
              "prompt": "Сопоставь литерал со стандартным типом, который выведет для него TypeScript.",
              "left": [
                "'TypeScript'",
                "17",
                "false",
                "[1, 2, 3]"
              ],
              "right": [
                "string",
                "number",
                "boolean",
                "number[]"
              ],
              "pairs": [
                {
                  "left": "'TypeScript'",
                  "right": "string"
                },
                {
                  "left": "17",
                  "right": "number"
                },
                {
                  "left": "false",
                  "right": "boolean"
                },
                {
                  "left": "[1, 2, 3]",
                  "right": "number[]"
                }
              ],
              "xp": 14,
              "tip": "Каждое значение принадлежит какому-то типу: строка, число, булево значение или, например, массив чисел."
            },
            {
              "id": "intro-typing-4",
              "type": "select-line",
              "prompt": "На какой строке допущена ошибка типов?",
              "lines": [
                "let count = 5;",
                "count = 'пять';",
                "console.log(count);"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Переменная count стала числом, значит ей нельзя присвоить значение другого типа.",
              "explanation": "Переменная count имеет тип number, поэтому ей нельзя присвоить строку."
            },
            {
              "id": "intro-typing-5",
              "type": "select-line",
              "prompt": "На какой строке присутствует несоответствие указанного типа?",
              "lines": [
                "function f(): string {",
                " return 123;",
                "}"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Убедись, что фактический возвращаемый тип совпадает с объявленным в сигнатуре.",
              "explanation": "Функция объявлена как возвращающая string, но возвращает number."
            },
            {
              "id": "intro-typing-6",
              "type": "fill",
              "prompt": "Заполни пропущенный тип:\nts\nlet username: ____ = 'Alice';\n",
              "placeholder": "тип",
              "answers": [
                "string"
              ],
              "xp": 10,
              "tip": "Для текстовых значений используется тип string."
            },
            {
              "id": "intro-typing-7",
              "type": "fill",
              "prompt": "Заполни пропущенный тип:\nts\nconst isOpen: ____ = false;\n",
              "placeholder": "тип",
              "answers": [
                "boolean"
              ],
              "xp": 10,
              "tip": "Логический тип в TypeScript называется boolean (не bool)."
            },
            {
              "id": "intro-typing-8",
              "type": "order",
              "prompt": "Собери корректное объявление переменной с числовым типом.",
              "tokens": [
                "let",
                "count",
                ":",
                "number",
                "=",
                "5",
                ";"
              ],
              "solution": [
                "let",
                "count",
                ":",
                "number",
                "=",
                "5",
                ";"
              ],
              "xp": 12,
              "tip": "После имени переменной через двоеточие указывается ее тип."
            },
            {
              "id": "intro-typing-9",
              "type": "choice",
              "prompt": "Какой тип выведется для переменной const nums = [10, 20, 30]?",
              "options": [
                "number[]",
                "any[]",
                "string[]",
                "number"
              ],
              "answer": "number[]",
              "xp": 10,
              "tip": "TypeScript выводит тип массива исходя из типов его элементов."
            },
            {
              "id": "intro-typing-10",
              "type": "choice",
              "prompt": "Обязательно ли указывать тип для каждой переменной в TypeScript?",
              "options": [
                "Нет, компилятор сможет вывести тип сам.",
                "Да, иначе код не скомпилируется.",
                "Только для чисел и boolean.",
                "Только если присваивается null."
              ],
              "answer": "Нет, компилятор сможет вывести тип сам.",
              "xp": 10,
              "tip": "TypeScript часто может сам понять тип переменной по ее значению."
            },
            {
              "id": "intro-typing-11",
              "type": "fill",
              "prompt": "TypeScript пытается _ тип переменной на основе присвоенного значения.",
              "placeholder": "действие",
              "answers": [
                "вывести"
              ],
              "xp": 10,
              "tip": "Вывод типа (type inference) — это определение типа без явного указания."
            }
          ]
        },
        {
          "id": "lvl-intro-dynamic",
          "title": "Проблемы динамической типизации",
          "goal": "Осознать, какие баги в JavaScript вызывает слабая динамическая типизация и как TypeScript их предотвращает.",
          "steps": [
            {
              "id": "intro-dynamic-1",
              "type": "choice",
              "prompt": "Почему слабая типизация в JavaScript приводит к трудноотлавливаемым ошибкам?",
              "options": [
                "Тип переменной может измениться во время выполнения без предупреждения.",
                "JavaScript запрещает использование чисел после строк.",
                "Все переменные автоматически становятся глобальными.",
                "В JavaScript отсутствуют условия и циклы."
              ],
              "answer": "Тип переменной может измениться во время выполнения без предупреждения.",
              "xp": 10,
              "tip": "Когда типы не зафиксированы, любые преобразования происходят уже на этапе запуска, и ошибка попадает к пользователю."
            },
            {
              "id": "intro-dynamic-2",
              "type": "choice",
              "prompt": "Какой результат выдаст выражение `'5' - 2` в чистом JavaScript?",
              "options": [
                "3",
                "'52'",
                "TypeError",
                "undefined"
              ],
              "answer": "3",
              "xp": 10,
              "tip": "Оператор - неявно приводит операнды к числу, поэтому строка '5' превращается в число."
            },
            {
              "id": "intro-dynamic-3",
              "type": "select-line",
              "prompt": "На какой строке проявится ошибка при выполнении этого кода в чистом JavaScript?",
              "lines": [
                "const user = { name: 'Neo' };",
                "function printAge(u) {",
                "  return u.age.toFixed(0);",
                "}",
                "console.log(printAge(user));"
              ],
              "answerLine": 3,
              "xp": 12,
              "tip": "В объекте user нет поля age — JavaScript обнаружит это только во время выполнения.",
              "explanation": "u.age равен undefined, поэтому вызов toFixed падает с ошибкой. TypeScript подсказал бы проблему ещё на этапе компиляции."
            },
            {
              "id": "intro-dynamic-4",
              "type": "match",
              "prompt": "Сопоставь проблему динамической типизации с её описанием.",
              "left": [
                "Неявное приведение",
                "Опечатка в свойстве",
                "Позднее обнаружение"
              ],
              "right": [
                "JavaScript автоматически меняет типы при операциях",
                "Код обращается к user.nmae и получает undefined",
                "Ошибка появляется уже у пользователя во время запуска"
              ],
              "pairs": [
                {
                  "left": "Неявное приведение",
                  "right": "JavaScript автоматически меняет типы при операциях"
                },
                {
                  "left": "Опечатка в свойстве",
                  "right": "Код обращается к user.nmae и получает undefined"
                },
                {
                  "left": "Позднее обнаружение",
                  "right": "Ошибка появляется уже у пользователя во время запуска"
                }
              ],
              "xp": 14,
              "tip": "Большинство багов динамической типизации связаны с тем, что язык молча пытается угадать тип или допускает обращение к любым свойствам."
            },
            {
              "id": "intro-dynamic-5",
              "type": "fill",
              "prompt": "В JavaScript тип переменной может ____ прямо по ходу выполнения программы.",
              "placeholder": "действие",
              "answers": [
                "меняться",
                "изменяться"
              ],
              "xp": 10,
              "tip": "Переменная может хранить число в одном месте и строку в другом, если язык не ограничивает тип."
            },
            {
              "id": "intro-dynamic-6",
              "type": "choice",
              "prompt": "Что добавляет TypeScript поверх динамически типизированного JavaScript?",
              "options": [
                "Проверку соответствия типов во время компиляции.",
                "Автоматическую оптимизацию производительности кода.",
                "Гарантию отсутствия логических ошибок.",
                "Запуск в отдельной виртуальной машине."
              ],
              "answer": "Проверку соответствия типов во время компиляции.",
              "xp": 10,
              "tip": "Компилятор TS анализирует контракты между частями программы и останавливает сборку при несоответствии."
            },
            {
              "id": "intro-dynamic-7",
              "type": "choice",
              "prompt": "Почему обращение к несуществующему полю user.age в проекте на TypeScript не попадёт в прод?",
              "options": [
                "Компилятор сообщит об ошибке несовместимых типов и не выпустит сборку.",
                "Браузер автоматически создаст поле age.",
                "TypeScript молча заменит значения на null.",
                "Такие обращения автоматически исправляются линтером."
              ],
              "answer": "Компилятор сообщит об ошибке несовместимых типов и не выпустит сборку.",
              "xp": 10,
              "tip": "Объекты имеют строгую структуру, и несоответствие будет найдено до запуска приложения."
            },
            {
              "id": "intro-dynamic-8",
              "type": "fill",
              "prompt": "Типовые аннотации в TypeScript выступают как ____ между частями программы.",
              "placeholder": "что?",
              "answers": [
                "контракты",
                "договоры"
              ],
              "xp": 10,
              "tip": "Контракт описывает форму данных и защищает от случайных изменений."
            },
            {
              "id": "intro-dynamic-9",
              "type": "order",
              "prompt": "Упорядочи этапы, через которые проходит ошибка типов в проекте на TypeScript.",
              "tokens": [
                "написать TypeScript-код",
                "tsc проверяет типы",
                "исправить найденные ошибки",
                "выполнить скомпилированный JavaScript"
              ],
              "solution": [
                "написать TypeScript-код",
                "tsc проверяет типы",
                "исправить найденные ошибки",
                "выполнить скомпилированный JavaScript"
              ],
              "xp": 12,
              "tip": "TypeScript ловит несоответствия до запуска JS-кода."
            },
            {
              "id": "intro-dynamic-10",
              "type": "choice",
              "prompt": "Что произойдёт, если функции calculateTotal(price: number) передать строку?",
              "options": [
                "Компилятор остановит сборку и попросит привести типы.",
                "Функция отработает, но вернёт undefined.",
                "TypeScript автоматически преобразует строку в число.",
                "Ничего — TypeScript игнорирует такие ошибки."
              ],
              "answer": "Компилятор остановит сборку и попросит привести типы.",
              "xp": 10,
              "tip": "Сигнатура функции объявляет контракт: любой другой тип аргумента вызовет ошибку компиляции."
            }
          ]
        },
        {
          "id": "lvl-intro-static",
          "title": "Статическая типизация",
          "goal": "Понять различия между явной, выводимой и структурной типизацией в TypeScript.",
          "steps": [
            {
              "id": "intro-static-1",
              "type": "choice",
              "prompt": "Что называют явной аннотацией типа?",
              "options": [
                "Ручное указание типа через двоеточие после имени сущности.",
                "Автоматическое определение типа компилятором.",
                "Использование типа any для переменной.",
                "Определение типа только в комментариях."
              ],
              "answer": "Ручное указание типа через двоеточие после имени сущности.",
              "xp": 10,
              "tip": "Явные аннотации делают контракт очевидным для других разработчиков."
            },
            {
              "id": "intro-static-2",
              "type": "choice",
              "prompt": "Какой тип выведет TypeScript для выражения const ratio = Math.random() > 0.3 ? 1 : 0?",
              "options": [
                "number",
                "boolean",
                "1 | 0",
                "any"
              ],
              "answer": "number",
              "xp": 10,
              "tip": "Оба возможных значения — числа, поэтому итоговый тип number."
            },
            {
              "id": "intro-static-3",
              "type": "match",
              "prompt": "Сопоставь термин с его описанием.",
              "left": [
                "Явная типизация",
                "Вывод типов",
                "Структурная типизация"
              ],
              "right": [
                "Разработчик сам указывает тип",
                "Компилятор определяет тип из значения",
                "Совместимость определяется набором свойств"
              ],
              "pairs": [
                {
                  "left": "Явная типизация",
                  "right": "Разработчик сам указывает тип"
                },
                {
                  "left": "Вывод типов",
                  "right": "Компилятор определяет тип из значения"
                },
                {
                  "left": "Структурная типизация",
                  "right": "Совместимость определяется набором свойств"
                }
              ],
              "xp": 14,
              "tip": "TypeScript сочетает все три подхода, чтобы сделать типы гибкими и строгими одновременно."
            },
            {
              "id": "intro-static-4",
              "type": "select-line",
              "prompt": "На какой строке нарушается структурный контракт интерфейса?",
              "lines": [
                "interface Author { name: string; posts: number; }",
                "const user = { name: 'Ada' };",
                "const author: Author = user;"
              ],
              "answerLine": 3,
              "xp": 12,
              "tip": "Структурная типизация требует, чтобы у объекта были все обязательные свойства интерфейса.",
              "explanation": "В user нет свойства posts, поэтому он не подходит под Author."
            },
            {
              "id": "intro-static-5",
              "type": "choice",
              "prompt": "Почему два интерфейса с одинаковыми полями считаются совместимыми между собой?",
              "options": [
                "TypeScript сравнивает только структуру типов.",
                "Компилятору важны лишь имена интерфейсов.",
                "Совместимость определяется порядком объявления в файле.",
                "Для совместимости нужно явно наследоваться."
              ],
              "answer": "TypeScript сравнивает только структуру типов.",
              "xp": 10,
              "tip": "Структурная типизация игнорирует имена и анализирует набор свойств и их типы."
            },
            {
              "id": "intro-static-6",
              "type": "fill",
              "prompt": "TypeScript использует ____ типизацию, поэтому важен состав свойств, а не имя типа.",
              "placeholder": "какую?",
              "answers": [
                "структурную"
              ],
              "xp": 10,
              "tip": "Структурный подход близок к тому, как мы описываем данные в JavaScript-объектах."
            },
            {
              "id": "intro-static-7",
              "type": "fill",
              "prompt": "Автоматическое определение типа переменной называется type ____.",
              "placeholder": "как?",
              "answers": [
                "inference",
                "инференция",
                "вывод"
              ],
              "xp": 10,
              "tip": "Можно писать по-русски \"вывод\", либо использовать английский термин inference."
            },
            {
              "id": "intro-static-8",
              "type": "choice",
              "prompt": "Когда стоит предпочесть явную аннотацию возвращаемого типа функции вместо доверия выводу?",
              "options": [
                "Когда важно задокументировать контракт функции и избежать неявного расширения типа.",
                "Когда функция содержит меньше трёх строк.",
                "Когда проект не использует ESLint.",
                "Когда функция объявлена только в тестах."
              ],
              "answer": "Когда важно задокументировать контракт функции и избежать неявного расширения типа.",
              "xp": 10,
              "tip": "Явный тип помогает IDE и коллегам понять, что функция должна возвращать."
            },
            {
              "id": "intro-static-9",
              "type": "order",
              "prompt": "Упорядочи шаги при добавлении нового структурного типа в кодовую базу.",
              "tokens": [
                "описать поля в интерфейсе или type",
                "создать значение, соответствующее структуре",
                "использовать тип в сигнатурах",
                "дать компилятору проверить совместимость"
              ],
              "solution": [
                "описать поля в интерфейсе или type",
                "создать значение, соответствующее структуре",
                "использовать тип в сигнатурах",
                "дать компилятору проверить совместимость"
              ],
              "xp": 12,
              "tip": "Сначала формулируем контракт, потом внедряем его в код и проверяем компилятором."
            },
            {
              "id": "intro-static-10",
              "type": "choice",
              "prompt": "Что произойдёт, если присвоить объект с дополнительным свойством типу, который этого свойства не описывает, но остальные поля совпадают?",
              "options": [
                "Присваивание пройдёт: лишние свойства игнорируются при структурной проверке.",
                "Компилятор запретит присваивание, пока не удалить свойство.",
                "TypeScript автоматически добавит новое свойство в тип.",
                "Такое присваивание возможно только через as any."
              ],
              "answer": "Присваивание пройдёт: лишние свойства игнорируются при структурной проверке.",
              "xp": 10,
              "tip": "Структурная типизация требует минимум свойств, но допускает дополнительные (за исключением проверки литеральных объектов)."
            }
          ]
        }
      ]
    },
    {
      "id": "unit-datatypes",
      "title": "Типы данных",
      "description": "Примитивные типы TypeScript (string, number, boolean и др.), а также специальные типы any, unknown, undefined, null, never.",
      "accent": "#3B82F6",
      "levels": [
        {
          "id": "lvl-primitives",
          "title": "Примитивные типы",
          "goal": "Познакомиться с основными примитивными типами: string, number, boolean, symbol, bigint.",
          "steps": [
            {
              "id": "data-primitives-1",
              "type": "choice",
              "prompt": "Какого из перечисленных примитивных типов не существует в TypeScript?",
              "options": [
                "string",
                "boolean",
                "int",
                "bigint"
              ],
              "answer": "int",
              "xp": 10,
              "tip": "В TypeScript нет отдельных типов для целых или дробных чисел вроде int — используется общий тип number."
            },
            {
              "id": "data-primitives-2",
              "type": "choice",
              "prompt": "Что верно про числовой тип number в TypeScript?",
              "options": [
                "Он используется и для целых, и для дробных чисел.",
                "Для целых чисел используется отдельный тип int.",
                "Тип number хранит только 32-битные целые числа.",
                "Для десятичных дробей нужен отдельный тип."
              ],
              "answer": "Он используется и для целых, и для дробных чисел.",
              "xp": 10,
              "tip": "В TypeScript, как и в JavaScript, один тип number представляет любые числа — и целые, и дробные."
            },
            {
              "id": "data-primitives-3",
              "type": "choice",
              "prompt": "Какого типа значение NaN (Not a Number) в TypeScript?",
              "options": [
                "number",
                "NaN",
                "undefined",
                "any"
              ],
              "answer": "number",
              "xp": 10,
              "tip": "Несмотря на название, NaN является специальным числовым значением (тип number)."
            },
            {
              "id": "data-primitives-4",
              "type": "match",
              "prompt": "Сопоставь название типа с примером литерала этого типа.",
              "left": [
                "string",
                "number",
                "boolean",
                "bigint",
                "symbol"
              ],
              "right": [
                "42",
                "\"TS\"",
                "true",
                "123n",
                "Symbol('id')"
              ],
              "pairs": [
                {
                  "left": "string",
                  "right": "\"TS\""
                },
                {
                  "left": "number",
                  "right": "42"
                },
                {
                  "left": "boolean",
                  "right": "true"
                },
                {
                  "left": "bigint",
                  "right": "123n"
                },
                {
                  "left": "symbol",
                  "right": "Symbol('id')"
                }
              ],
              "xp": 14,
              "tip": "TypeScript поддерживает такие примитивные типы: строки, числа, булевы значения, большие целые (bigint) и символы (symbol)."
            },
            {
              "id": "data-primitives-5",
              "type": "fill",
              "prompt": "Исправь тип в объявлении:\nts\nlet x: int = 5;\n",
              "placeholder": "тип",
              "answers": [
                "number"
              ],
              "xp": 10,
              "tip": "Для любых чисел в TypeScript используется тип number."
            },
            {
              "id": "data-primitives-6",
              "type": "choice",
              "prompt": "Как в коде обозначается литерал типа BigInt?",
              "options": [
                "Число с суффиксом n",
                "Число с суффиксом b",
                "Обычное число без десятичной точки",
                "Специальный синтаксис не требуется"
              ],
              "answer": "Число с суффиксом n",
              "xp": 10,
              "tip": "Большие целые (BigInt) обозначаются литералами с постфиксом n (например, 123n)."
            },
            {
              "id": "data-primitives-7",
              "type": "choice",
              "prompt": "Для чего применяется тип symbol в TypeScript?",
              "options": [
                "Для создания уникальных идентификаторов",
                "Для представления одиночного символа текста",
                "Для хранения двоичных данных",
                "Для обозначения пустого значения"
              ],
              "answer": "Для создания уникальных идентификаторов",
              "xp": 10,
              "tip": "Значения типа symbol уникальны. Их часто используют как ключи объектов, чтобы избежать конфликтов."
            },
            {
              "id": "data-primitives-8",
              "type": "choice",
              "prompt": "Как создать новое значение типа symbol?",
              "options": [
                "Symbol('id')",
                "new Symbol('id')",
                "'id' as symbol",
                "Symbol.make('id')"
              ],
              "answer": "Symbol('id')",
              "xp": 10,
              "tip": "Значение типа symbol создается вызовом встроенной функции Symbol()."
            },
            {
              "id": "data-primitives-9",
              "type": "select-line",
              "prompt": "На какой строке ошибка: попытка сложить bigint и number?",
              "lines": [
                "const a = 1n;",
                "const b = 2;",
                "const sum = a + b;",
                "console.log(sum);"
              ],
              "answerLine": 3,
              "xp": 12,
              "tip": "В одном выражении все операнды должны быть одного типа (либо все bigint, либо все number).",
              "explanation": "Нельзя напрямую складывать значения разных типов bigint и number."
            },
            {
              "id": "data-primitives-10",
              "type": "select-line",
              "prompt": "На какой строке допущена ошибка при присваивании значения примитивного типа?",
              "lines": [
                "let answer: boolean = 'yes';",
                "console.log(answer);"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Логический тип (boolean) принимает только значения true или false (без кавычек).",
              "explanation": "Строку нельзя присвоить переменной типа boolean."
            }
          ]
        },
        {
          "id": "lvl-any-unknown",
          "title": "Any и Unknown",
          "goal": "Освоить использование типов any и unknown и понять их различия.",
          "steps": [
            {
              "id": "data-any-unknown-diff",
              "type": "choice",
              "prompt": "Что отличает тип unknown от типа any?",
              "options": [
                "Нельзя использовать значение типа unknown без предварительной проверки.",
                "Тип unknown менее безопасен, чем any.",
                "Тип unknown можно неявно преобразовать в любой другой тип.",
                "Тип unknown означает, что значение отсутствует."
              ],
              "answer": "Нельзя использовать значение типа unknown без предварительной проверки.",
              "xp": 10,
              "tip": "unknown требует проверки типа перед использованием, поэтому считается более безопасной альтернативой any."
            },
            {
              "id": "data-any-best",
              "type": "choice",
              "prompt": "Как следует использовать тип any при разработке?",
              "options": [
                "Избегать использования any без крайней необходимости.",
                "Активно использовать any для ускорения разработки.",
                "Заменять все неизвестные типы на any.",
                "Всегда использовать any вместо unknown."
              ],
              "answer": "Избегать использования any без крайней необходимости.",
              "xp": 10,
              "tip": "Использование any скрывает проблемы — старайся явно прописывать типы или использовать unknown, требующий проверки."
            },
            {
              "id": "data-unknown-assign",
              "type": "choice",
              "prompt": "Какие значения можно присвоить переменной типа unknown?",
              "options": [
                "Значения любого типа.",
                "Только значения типа unknown или any.",
                "Только значения примитивных типов.",
                "Никакие (невозможно присвоить значение)."
              ],
              "answer": "Значения любого типа.",
              "xp": 10,
              "tip": "Переменной типа unknown можно присвоить значение любого типа. Однако само значение unknown нельзя присвоить переменной более узкого типа без проверки."
            },
            {
              "id": "data-any-assign",
              "type": "choice",
              "prompt": "Можно ли значение типа any присвоить переменной типа number?",
              "options": [
                "Да, any присваивается к переменной любого типа без ошибки.",
                "Нет, компилятор потребует приведение типа.",
                "Только если значение действительно число.",
                "Только в нестрогом режиме."
              ],
              "answer": "Да, any присваивается к переменной любого типа без ошибки.",
              "xp": 10,
              "tip": "any отключает проверки типов: его можно присвоить переменной любого типа (но это опасно)."
            },
            {
              "id": "data-any-runtime",
              "type": "choice",
              "prompt": "Что произойдет при выполнении следующего кода?\nts\nlet data: any = 123;\nconsole.log(data.toUpperCase());\n",
              "options": [
                "Будет ошибка во время выполнения.",
                "TypeScript выдаст ошибку при компиляции.",
                "Сообщение \"123\" выведется в верхнем регистре.",
                "Код ничего не выведет."
              ],
              "answer": "Будет ошибка во время выполнения.",
              "xp": 10,
              "tip": "Тип any не проверяется компилятором, поэтому ошибка (вызов метода не по типу) проявится только при запуске."
            },
            {
              "id": "data-any-unknown-match",
              "type": "match",
              "prompt": "Сопоставь тип с его свойством.",
              "left": [
                "any",
                "unknown"
              ],
              "right": [
                "Можно выполнять любые операции без ошибок компиляции",
                "Требует явной проверки типа перед использованием"
              ],
              "pairs": [
                {
                  "left": "any",
                  "right": "Можно выполнять любые операции без ошибок компиляции"
                },
                {
                  "left": "unknown",
                  "right": "Требует явной проверки типа перед использованием"
                }
              ],
              "xp": 12,
              "tip": "any позволяет игнорировать проверки типов (любой код компилируется), а с unknown необходимо сначала проверить тип значения."
            },
            {
              "id": "data-unknown-prefer",
              "type": "fill",
              "prompt": "Вместо типа any рекомендуется использовать для значения неизвестного типа.",
              "placeholder": "тип",
              "answers": [
                "unknown"
              ],
              "xp": 10,
              "tip": "Тип unknown заставит явно проверить тип значения перед использованием, повышая безопасность."
            },
            {
              "id": "data-any-disable",
              "type": "fill",
              "prompt": "Чтобы отключить проверку типов для переменной, можно указать тип ____.",
              "placeholder": "тип",
              "answers": [
                "any"
              ],
              "xp": 10,
              "tip": "any убирает все ограничения типов (используется с осторожностью)."
            },
            {
              "id": "data-unknown-method",
              "type": "select-line",
              "prompt": "На какой строке ошибка при использовании значения типа unknown?",
              "lines": [
                "let input: unknown = 'Hello';",
                "console.log(input.toUpperCase());"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Сначала нужно убедиться, что input — строка, прежде чем вызывать у него string-методы.",
              "explanation": "Нельзя вызывать методы у значения типа unknown без проверки его типа."
            },
            {
              "id": "data-unknown-assign-error",
              "type": "select-line",
              "prompt": "На какой строке ошибка присваивания несовместимого типа?",
              "lines": [
                "let val: unknown = 42;",
                "let num: number = val;",
                "num += 1;"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Нельзя присвоить значение типа unknown переменной типа number без приведения или сужения типа.",
              "explanation": "Тип unknown не может быть неявно приведён к number."
            }
          ]
        },
        {
          "id": "lvl-null-undef",
          "title": "Null и Undefined",
          "goal": "Научиться работать с отсутствующими значениями (null, undefined) и разрешать их использование.",
          "steps": [
            {
              "id": "data-null-undef-both",
              "type": "choice",
              "prompt": "Какие значения в JavaScript/TypeScript обозначают отсутствие значения?",
              "options": [
                "null и undefined",
                "только undefined",
                "только null",
                "void"
              ],
              "answer": "null и undefined",
              "xp": 10,
              "tip": "В языке есть два специальных значения: undefined (значение не присвоено) и null (отсутствие значения явно)."
            },
            {
              "id": "data-null-undef-diff-q",
              "type": "choice",
              "prompt": "Что верно относительно различия между null и undefined?",
              "options": [
                "undefined обычно означает, что значение не присвоено, а null указывает на намеренное отсутствие значения.",
                "null и undefined взаимозаменяемы, между ними нет разницы.",
                "undefined используется только при строгой типизации.",
                "null автоматически присваивается всем необъявленным переменным."
              ],
              "answer": "undefined обычно означает, что значение не присвоено, а null указывает на намеренное отсутствие значения.",
              "xp": 10,
              "tip": "undefined появляется, когда переменной ничего не присвоили, а null часто ставят явно, чтобы обозначить отсутствие значения."
            },
            {
              "id": "data-null-assign-error",
              "type": "select-line",
              "prompt": "На какой строке ошибка присваивания null несовместимому типу?",
              "lines": [
                "let username: string = null;",
                "console.log(username);"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Если переменная должна быть null, ее тип нужно явно объединить с null.",
              "explanation": "Тип string не позволяет присвоить null (при включенном strictNullChecks)."
            },
            {
              "id": "data-undef-assign-error",
              "type": "select-line",
              "prompt": "На какой строке ошибка из-за присваивания undefined несовместимому типу?",
              "lines": [
                "let count: number = undefined;",
                "console.log(count);"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Чтобы переменная могла быть undefined, ее тип должен это допускать (например, number | undefined).",
              "explanation": "Без объединения с undefined тип number не может содержать значение undefined."
            },
            {
              "id": "data-null-undef-diff",
              "type": "match",
              "prompt": "Сопоставь значение с его описанием.",
              "left": [
                "null",
                "undefined"
              ],
              "right": [
                "значение отсутствует (явно указано)",
                "значение не задано (по умолчанию)"
              ],
              "pairs": [
                {
                  "left": "null",
                  "right": "значение отсутствует (явно указано)"
                },
                {
                  "left": "undefined",
                  "right": "значение не задано (по умолчано)"
                }
              ],
              "xp": 12,
              "tip": "Неинициализированным переменным присваивается undefined. Значение null обычно указывают явно, чтобы обозначить отсутствие данных."
            },
            {
              "id": "data-null-union-fill",
              "type": "fill",
              "prompt": "Сделай переменную способной хранить null:\nts\nlet score: number ____ null = null;\n",
              "placeholder": "|",
              "answers": [
                "|"
              ],
              "xp": 10,
              "tip": "Для объединения типов используй символ вертикальной черты |."
            },
            {
              "id": "data-null-undef-union-match",
              "type": "match",
              "prompt": "Где тип переменной допускает указанные значения?",
              "left": [
                "let a: string = 'hi';",
                "let b: string | undefined = ...;",
                "let c: string | null = ...;"
              ],
              "right": [
                "переменная не может быть ни null, ни undefined",
                "переменная может быть undefined",
                "переменная может быть null"
              ],
              "pairs": [
                {
                  "left": "let a: string = 'hi';",
                  "right": "переменная не может быть ни null, ни undefined"
                },
                {
                  "left": "let b: string | undefined = ...;",
                  "right": "переменная может быть undefined"
                },
                {
                  "left": "let c: string | null = ...;",
                  "right": "переменная может быть null"
                }
              ],
              "xp": 14,
              "tip": "Если нужно разрешить undefined или null, добавляй их через |. Без этого, например, string не включает ни null, ни undefined."
            },
            {
              "id": "data-undef-default",
              "type": "choice",
              "prompt": "В каком случае переменная примет значение undefined?",
              "options": [
                "Если она объявлена, но ей не присвоено значение.",
                "Если ей присвоено значение null.",
                "Если она выходит за область видимости.",
                "Если при вычислении выражения произошла ошибка."
              ],
              "answer": "Если она объявлена, но ей не присвоено значение.",
              "xp": 10,
              "tip": "Неинициализированные переменные по умолчанию имеют значение undefined."
            },
            {
              "id": "data-no-return",
              "type": "choice",
              "prompt": "Что вернёт функция, если внутри неё нет ни одного оператора return?",
              "options": [
                "undefined",
                "null",
                "0",
                "void"
              ],
              "answer": "undefined",
              "xp": 10,
              "tip": "Если функция не возвращает значение явно, она неявно возвращает undefined."
            },
            {
              "id": "data-void-func",
              "type": "choice",
              "prompt": "Какой тип следует указать у функции, которая ничего не возвращает?",
              "options": [
                "void",
                "undefined",
                "any",
                "never"
              ],
              "answer": "void",
              "xp": 10,
              "tip": "Для функций, не возвращающих значение, в TypeScript предусмотрен отдельный тип void."
            }
          ]
        },
        {
          "id": "lvl-never",
          "title": "Never",
          "goal": "Понять назначение типа never и когда он применяется.",
          "steps": [
            {
              "id": "data-never-usage",
              "type": "choice",
              "prompt": "В каких случаях применяется тип never?",
              "options": [
                "Для функций, которые не возвращают значение (бросают исключение или зацикливаются).",
                "Для всех функций, которые ничего не возвращают (аналог void).",
                "Для значения undefined или null.",
                "Для переменных, тип которых неизвестен."
              ],
              "answer": "Для функций, которые не возвращают значение (бросают исключение или зацикливаются).",
              "xp": 10,
              "tip": "Тип never используется, например, для функций, которые всегда выбрасывают ошибку или зациклены (никогда не возвращаются)."
            },
            {
              "id": "data-never-vs-void",
              "type": "choice",
              "prompt": "Чем отличается тип never от типа void?",
              "options": [
                "never означает, что функция не завершится, а void — что функция завершится без возвращаемого значения.",
                "Не отличаются, это синонимы.",
                "void строже, чем never.",
                "never используется только с async-функциями."
              ],
              "answer": "never означает, что функция не завершится, а void — что функция завершится без возвращаемого значения.",
              "xp": 10,
              "tip": "Тип void обозначает отсутствие возвращаемого значения (функция выполняется и возвращает undefined). never означает, что функция вообще не завершится."
            },
            {
              "id": "data-never-assignable",
              "type": "choice",
              "prompt": "Можно ли значение типа never присвоить переменной любого другого типа?",
              "options": [
                "Да, never можно присвоить переменной любого типа.",
                "Нет, never не совместим ни с одним другим типом.",
                "Только переменной типа void.",
                "Только если strictNullChecks выключен."
              ],
              "answer": "Да, never можно присвоить переменной любого типа.",
              "xp": 10,
              "tip": "Тип never является подтипом всех типов, поэтому значение типа never можно присвоить переменной любого типа."
            },
            {
              "id": "data-never-assignable2",
              "type": "choice",
              "prompt": "Можно ли значение типа string присвоить переменной типа never?",
              "options": [
                "Нет, значение никакого типа не может быть присвоено переменной типа never.",
                "Да, never может принимать любое значение.",
                "Только значение undefined можно присвоить.",
                "Только при отключенной строгой типизации."
              ],
              "answer": "Нет, значение никакого типа не может быть присвоено переменной типа never.",
              "xp": 10,
              "tip": "Переменная типа never не может содержать никаких значений (к ней ничего нельзя присвоить)."
            },
            {
              "id": "data-never-function",
              "type": "choice",
              "prompt": "Какой функции следует указать возвращаемый тип never?",
              "options": [
                "function error() { throw new Error('Oops'); }",
                "function exit() { return; }",
                "function print(): never { console.log('Hi'); }",
                "function sum(a, b) { return a + b; }"
              ],
              "answer": "function error() { throw new Error('Oops'); }",
              "xp": 10,
              "tip": "Функция, которая всегда выбрасывает ошибку и не возвращает значение, должна иметь тип never."
            },
            {
              "id": "data-never-fill1",
              "type": "fill",
              "prompt": "Заполни возвращаемый тип функции:\nts\nfunction fail(message: string): ____ {\n throw new Error(message);\n}\n",
              "placeholder": "тип",
              "answers": [
                "never"
              ],
              "xp": 10,
              "tip": "Функция, выбрасывающая исключение, не возвращает значение, поэтому её тип — never."
            },
            {
              "id": "data-never-fill2",
              "type": "fill",
              "prompt": "Заполни возвращаемый тип бесконечной функции:\nts\nfunction loop(): ____ {\n while(true) {}\n}\n",
              "placeholder": "тип",
              "answers": [
                "never"
              ],
              "xp": 10,
              "tip": "Функция с бесконечным циклом никогда не завершится, её возвращаемый тип — never."
            },
            {
              "id": "data-never-assign-error",
              "type": "select-line",
              "prompt": "На какой строке возникает ошибка присваивания несовместимого значения?",
              "lines": [
                "let n: never = 5;",
                "let m: number = 5;"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Переменной типа never нельзя присвоить никакое реальное значение.",
              "explanation": "Значение типа number не может быть присвоено переменной типа never."
            },
            {
              "id": "data-never-union",
              "type": "choice",
              "prompt": "Чему эквивалентен тип string | never?",
              "options": [
                "string",
                "never",
                "any",
                "unknown"
              ],
              "answer": "string",
              "xp": 10,
              "tip": "Объединение с never не расширяет тип. Поэтому string | never то же самое, что и string."
            },
            {
              "id": "data-never-valid",
              "type": "match",
              "prompt": "Определи, какое объявление функции корректно, а какое содержит ошибку.",
              "left": [
                "function f(): never { throw new Error('Boom'); }",
                "function g(): never { return; }"
              ],
              "right": [
                "корректное объявление",
                "ошибочное объявление"
              ],
              "pairs": [
                {
                  "left": "function f(): never { throw new Error('Boom'); }",
                  "right": "корректное объявление"
                },
                {
                  "left": "function g(): never { return; }",
                  "right": "ошибочное объявление"
                }
              ],
              "xp": 12,
              "tip": "Функция с объявленным never обязана не вернуться вовсе. return; в ней неприемлем — нужен throw или бесконечный цикл."
            }
          ]
        },
        {
          "id": "lvl-special-types",
          "title": "Специальные типы и void",
          "goal": "Систематизировать знания об any, unknown, never и void и понять их роли в системе типов.",
          "steps": [
            {
              "id": "data-special-1",
              "type": "choice",
              "prompt": "Какой тип возвращаемого значения следует указать у функции log(message: string), если она ничего не возвращает?",
              "options": [
                "void",
                "undefined",
                "never",
                "any"
              ],
              "answer": "void",
              "xp": 10,
              "tip": "Функция, цель которой — побочный эффект (логирование), объявляется как возвращающая void."
            },
            {
              "id": "data-special-2",
              "type": "select-line",
              "prompt": "На какой строке функция с типом void нарушает контракт?",
              "lines": [
                "function warn(message: string): void {",
                "  return message;",
                "}"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Функция с типом void не должна возвращать значение.",
              "explanation": "Возвращение строки нарушает объявленный контракт void."
            },
            {
              "id": "data-special-3",
              "type": "match",
              "prompt": "Сопоставь специальный тип с его назначением.",
              "left": [
                "any",
                "unknown",
                "never",
                "void"
              ],
              "right": [
                "Отключает проверки типов",
                "Безопасный верхний тип, требует проверки перед использованием",
                "Нижний тип: значения не существует",
                "Тип для функций без возвращаемого значения"
              ],
              "pairs": [
                {
                  "left": "any",
                  "right": "Отключает проверки типов"
                },
                {
                  "left": "unknown",
                  "right": "Безопасный верхний тип, требует проверки перед использованием"
                },
                {
                  "left": "never",
                  "right": "Нижний тип: значения не существует"
                },
                {
                  "left": "void",
                  "right": "Тип для функций без возвращаемого значения"
                }
              ],
              "xp": 14,
              "tip": "Помни: any стоит использовать только временно, а unknown — предпочтительный безопасный вариант."
            },
            {
              "id": "data-special-4",
              "type": "choice",
              "prompt": "Какой тип принято считать \"верхним\" безопасным типом, которому можно присвоить значение любого другого типа?",
              "options": [
                "unknown",
                "any",
                "never",
                "void"
              ],
              "answer": "unknown",
              "xp": 10,
              "tip": "unknown принимает любые значения, но не даёт использовать их без проверки."
            },
            {
              "id": "data-special-5",
              "type": "fill",
              "prompt": "Тип ____ считается нижним: он совместим с любым типом, но не содержит значений.",
              "placeholder": "название",
              "answers": [
                "never"
              ],
              "xp": 10,
              "tip": "never появляется, когда выполнение кода невозможно завершить (throw, бесконечный цикл)."
            },
            {
              "id": "data-special-6",
              "type": "choice",
              "prompt": "Можно ли напрямую присвоить значение типа unknown переменной типа string?",
              "options": [
                "Нет, сначала нужно сузить тип или привести его явно.",
                "Да, unknown автоматически приводится к string.",
                "Да, если значение было получено из JSON.",
                "Только при отключенном strict режиме."
              ],
              "answer": "Нет, сначала нужно сузить тип или привести его явно.",
              "xp": 10,
              "tip": "unknown защищает от случайных присваиваний: требуется проверка typeof либо пользовательский guard."
            },
            {
              "id": "data-special-7",
              "type": "select-line",
              "prompt": "На какой строке нарушается совместимость типов void?",
              "lines": [
                "let result: void = undefined;",
                "let total: number = result;",
                "console.log(total);"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Значение void нельзя неявно присваивать переменным другого типа.",
              "explanation": "result имеет тип void, поэтому его нельзя присвоить number без приведения."
            },
            {
              "id": "data-special-8",
              "type": "choice",
              "prompt": "Чем тип void отличается от значения undefined?",
              "options": [
                "void — тип, описывающий отсутствие значения; undefined — одно из возможных значений.",
                "void — конкретное значение, а undefined — тип.",
                "Они идентичны и взаимозаменяемы.",
                "undefined нельзя использовать в TypeScript."
              ],
              "answer": "void — тип, описывающий отсутствие значения; undefined — одно из возможных значений.",
              "xp": 10,
              "tip": "Тип void допускает как undefined, так и отсутствие выражения в return."
            },
            {
              "id": "data-special-9",
              "type": "fill",
              "prompt": "Тип any фактически отключает ____ компилятора.",
              "placeholder": "что?",
              "answers": [
                "проверки",
                "проверки типов"
              ],
              "xp": 10,
              "tip": "Используй any только как временную заглушку, иначе ошибки всплывут уже на проде."
            },
            {
              "id": "data-special-10",
              "type": "order",
              "prompt": "Расставь типы от самого строгого (минимум значений) к самому свободному.",
              "tokens": [
                "never",
                "unknown",
                "any"
              ],
              "solution": [
                "never",
                "unknown",
                "any"
              ],
              "xp": 12,
              "tip": "never ⟶ unknown ⟶ any — типичная шкала снижения строгости."
            }
          ]
        },
        {
          "id": "lvl-subtypes",
          "title": "Подтипы и надтипы",
          "goal": "Разобраться, как работает отношение подтипов и надтипов в TypeScript и как оно влияет на присваивания.",
          "steps": [
            {
              "id": "data-subtypes-1",
              "type": "choice",
              "prompt": "Что означает утверждение \"A является подтипом B\"?",
              "options": [
                "Любое значение A можно присвоить переменной типа B.",
                "Тип A шире и содержит больше значений, чем B.",
                "A и B обязаны иметь одинаковые поля.",
                "A автоматически превращается в B при компиляции."
              ],
              "answer": "Любое значение A можно присвоить переменной типа B.",
              "xp": 10,
              "tip": "Подтип — это более узкий набор значений, который совместим с надтипом."
            },
            {
              "id": "data-subtypes-2",
              "type": "choice",
              "prompt": "Является ли string подтипом типа string | number?",
              "options": [
                "Да, string — один из вариантов объединения.",
                "Нет, объединение всегда уже своих членов.",
                "Только если включен strictNullChecks.",
                "Зависит от значения переменной."
              ],
              "answer": "Да, string — один из вариантов объединения.",
              "xp": 10,
              "tip": "Union шире любого из своих участников."
            },
            {
              "id": "data-subtypes-3",
              "type": "choice",
              "prompt": "Можно ли без проверки присвоить переменную типа string | number переменной типа string?",
              "options": [
                "Нет, поскольку значение может оказаться числом.",
                "Да, union автоматически сузится до string.",
                "Да, но только если значение создано как литерал.",
                "Разрешено, если компилятор не в строгом режиме."
              ],
              "answer": "Нет, поскольку значение может оказаться числом.",
              "xp": 10,
              "tip": "Нельзя присваивать более широкий тип более узкому без явного сужения."
            },
            {
              "id": "data-subtypes-4",
              "type": "match",
              "prompt": "Определи, допустимо ли присваивание.",
              "left": [
                "string → string | number",
                "number → unknown",
                "never → boolean",
                "unknown → number"
              ],
              "right": [
                "разрешено: целевой тип шире",
                "разрешено: unknown — верхний тип",
                "разрешено: нижний тип совместим со всеми",
                "запрещено: нельзя присваивать надтип более узкому"
              ],
              "pairs": [
                {
                  "left": "string → string | number",
                  "right": "разрешено: целевой тип шире"
                },
                {
                  "left": "number → unknown",
                  "right": "разрешено: unknown — верхний тип"
                },
                {
                  "left": "never → boolean",
                  "right": "разрешено: нижний тип совместим со всеми"
                },
                {
                  "left": "unknown → number",
                  "right": "запрещено: нельзя присваивать надтип более узкому"
                }
              ],
              "xp": 14,
              "tip": "Помни: присваиваемое значение должно быть не шире целевого типа."
            },
            {
              "id": "data-subtypes-5",
              "type": "fill",
              "prompt": "Тип, содержащий больше значений, называют ____ типом.",
              "placeholder": "как?",
              "answers": [
                "надтипом",
                "supertype"
              ],
              "xp": 10,
              "tip": "Например, string — надтип для литералов 'ok' | 'fail'."
            },
            {
              "id": "data-subtypes-6",
              "type": "fill",
              "prompt": "Тип, который содержит меньше значений и может быть назначен надтипу, называется ____.",
              "placeholder": "как?",
              "answers": [
                "подтипом",
                "subtype"
              ],
              "xp": 10,
              "tip": "Литеральный тип 'ok' — подтип строкового типа string."
            },
            {
              "id": "data-subtypes-7",
              "type": "select-line",
              "prompt": "На какой строке нарушено правило присваивания подтип → надтип?",
              "lines": [
                "let response: string = 'ok';",
                "const status: 'ok' | 'fail' = response;",
                "console.log(status);"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Присваивать можно только из подтипа в надтип, а не наоборот.",
              "explanation": "response имеет тип string (шире), поэтому его нельзя присвоить более узкому литеральному типу без проверки."
            },
            {
              "id": "data-subtypes-8",
              "type": "choice",
              "prompt": "Почему значение типа never можно присвоить переменной любого другого типа?",
              "options": [
                "never не имеет значений, поэтому условие \"любой элемент из never принадлежит T\" выполняется автоматически.",
                "Компилятор автоматически преобразует never в нужный тип.",
                "never хранит ссылку на все значения.",
                "Так устроен только JavaScript, но не TypeScript."
              ],
              "answer": "never не имеет значений, поэтому условие \"любой элемент из never принадлежит T\" выполняется автоматически.",
              "xp": 10,
              "tip": "Отсутствие значений => отсутствие противоречий при присваивании."
            },
            {
              "id": "data-subtypes-9",
              "type": "order",
              "prompt": "Упорядочи типы по возрастанию множества значений.",
              "tokens": [
                "never",
                "string",
                "string | number",
                "unknown"
              ],
              "solution": [
                "never",
                "string",
                "string | number",
                "unknown"
              ],
              "xp": 12,
              "tip": "Каждый следующий тип включает предыдущий."
            },
            {
              "id": "data-subtypes-10",
              "type": "choice",
              "prompt": "Какой тип является надтипом для литерального типа 'on'?",
              "options": [
                "string",
                "'off'",
                "never",
                "boolean"
              ],
              "answer": "string",
              "xp": 10,
              "tip": "Любая строка включает конкретные строковые литералы как подтипы."
            }
          ]
        }
      ]
    },
    {
      "id": "unit-complex",
      "title": "Комплексные типы",
      "description": "Составные типы: объекты, массивы, кортежи, объединения (union) и пересечения (intersection).",
      "accent": "#10B981",
      "levels": [
        {
          "id": "lvl-objects",
          "title": "Объектные типы и интерфейсы",
          "goal": "Научиться описывать структуру объектов с помощью интерфейсов и тип-алиасов.",
          "steps": [
            {
              "id": "complex-obj-match",
              "type": "match",
              "prompt": "Сопоставь объявление типа с его описанием.",
              "left": [
                "interface User { name: string; age: number; }",
                "type User = { name: string; age: number; }",
                "let user: { name: string; age: number; } = { ... };"
              ],
              "right": [
                "объявление интерфейса User",
                "объявление type-алиаса User",
                "использование объектного типа без отдельного имени"
              ],
              "pairs": [
                {
                  "left": "interface User { name: string; age: number; }",
                  "right": "объявление интерфейса User"
                },
                {
                  "left": "type User = { name: string; age: number; }",
                  "right": "объявление type-алиаса User"
                },
                {
                  "left": "let user: { name: string; age: number; } = { ... };",
                  "right": "использование объектного типа без отдельного имени"
                }
              ],
              "xp": 14,
              "tip": "Объектный тип можно задать прямо в месте использования или создать ему имя — через interface или type ... = {...}."
            },
            {
              "id": "complex-obj-define",
              "type": "choice",
              "prompt": "Чем можно описать структуру объекта в TypeScript?",
              "options": [
                "И интерфейсом, и type-алиасом.",
                "Только интерфейсом (interface).",
                "Только type-алиасом (type).",
                "Никак, у объектов нет типов."
              ],
              "answer": "И интерфейсом, и type-алиасом.",
              "xp": 10,
              "tip": "Для описания формата объекта можно использовать и interface, и type — выбери то, что удобнее в контексте."
            },
            {
              "id": "complex-missing-prop",
              "type": "select-line",
              "prompt": "На какой строке ошибка: объект не соответствует объявленному типу?",
              "lines": [
                "interface Person { name: string; }",
                "const person: Person = {};"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Все обязательные свойства, объявленные в типе Person, должны присутствовать в объекте.",
              "explanation": "Объект не соответствует типу Person: отсутствует свойство name."
            },
            {
              "id": "complex-prop-type",
              "type": "select-line",
              "prompt": "На какой строке ошибка в типе свойства объекта?",
              "lines": [
                "interface Pet { name: string; age: number; }",
                "let pet: Pet = { name: 'Fluffy', age: '5' };"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Типы свойств объекта должны совпадать с объявленными в интерфейсе.",
              "explanation": "Свойство age должно быть числом, но указано строковое значение."
            },
            {
              "id": "complex-optional-fill",
              "type": "fill",
              "prompt": "Сделай свойство age необязательным:\nts\ninterface User {\n name: string;\n age____: number;\n}\n",
              "placeholder": "?",
              "answers": [
                "?"
              ],
              "xp": 10,
              "tip": "Необязательное свойство помечается знаком вопроса ? после имени."
            },
            {
              "id": "complex-optional-use",
              "type": "choice",
              "prompt": "Если свойство интерфейса помечено как необязательное (?), что будет, если не указать его в объекте?",
              "options": [
                "Компилятор не выдаст ошибку.",
                "Будет ошибка компиляции.",
                "Свойство получит значение по умолчанию.",
                "Тип объекта станет any."
              ],
              "answer": "Компилятор не выдаст ошибку.",
              "xp": 10,
              "tip": "Необязательное свойство можно вовсе не указывать при создании объекта этого типа."
            },
            {
              "id": "complex-structural",
              "type": "choice",
              "prompt": "Если два интерфейса имеют одинаковые поля, будут ли объекты этих типов совместимы?",
              "options": [
                "Да, TypeScript сравнивает типы по структуре, а не по имени.",
                "Нет, разные названия интерфейсов делают типы несовместимыми.",
                "Только если интерфейсы объявлены в одном файле.",
                "Только при использовании специального ключевого слова совместимости."
              ],
              "answer": "Да, TypeScript сравнивает типы по структуре, а не по имени.",
              "xp": 10,
              "tip": "TypeScript использует структурную типизацию: совместимость определяется набором полей и их типами, а не именем типа."
            },
            {
              "id": "complex-index-sign",
              "type": "choice",
              "prompt": "Как объявить интерфейс для объекта с произвольными строковыми ключами и числовыми значениями?",
              "options": [
                "interface X { [key: string]: number; }",
                "interface X { key: string: number; }",
                "interface X { string: number; }",
                "interface X { [number]: string; }"
              ],
              "answer": "interface X { [key: string]: number; }",
              "xp": 10,
              "tip": "Запись вида [key: string]: number внутри интерфейса означает, что объект может иметь свойства с любыми именами (string), а значения этих свойств — числа."
            },
            {
              "id": "complex-class-impl",
              "type": "choice",
              "prompt": "Может ли класс реализовать (implements) интерфейс?",
              "options": [
                "Да, класс может implement-интерфейс, обязуясь иметь указанные свойства/методы.",
                "Нет, интерфейсы предназначены только для типизации объектов, а не классов.",
                "Только если класс наследуется от другого класса.",
                "В TypeScript классы не поддерживают интерфейсы."
              ],
              "answer": "Да, класс может implement-интерфейс, обязуясь иметь указанные свойства/методы.",
              "xp": 10,
              "tip": "Классы могут реализовывать интерфейсы через implements — компилятор проверит, что класс содержит указанные в интерфейсе поля и методы."
            },
            {
              "id": "complex-interface-order",
              "type": "order",
              "prompt": "Собери объявление интерфейса User с полями name (string) и age (number).",
              "tokens": [
                "interface",
                "User",
                "{",
                "name:",
                "string;",
                "age:",
                "number;",
                "}"
              ],
              "solution": [
                "interface",
                "User",
                "{",
                "name:",
                "string;",
                "age:",
                "number;",
                "}"
              ],
              "xp": 12,
              "tip": "В интерфейсе внутри фигурных скобок перечисляются свойства и их типы."
            }
          ]
        },
        {
          "id": "lvl-arrays-tuples",
          "title": "Массивы и кортежи",
          "goal": "Научиться описывать массивы и кортежи (tuple) разных типов.",
          "steps": [
            {
              "id": "complex-array-tuple-match",
              "type": "match",
              "prompt": "Сопоставь объявление типа с его значением.",
              "left": [
                "string[]",
                "[number, number]",
                "boolean[]"
              ],
              "right": [
                "массив строк",
                "кортеж из двух чисел",
                "массив логических значений"
              ],
              "pairs": [
                {
                  "left": "string[]",
                  "right": "массив строк"
                },
                {
                  "left": "[number, number]",
                  "right": "кортеж из двух чисел"
                },
                {
                  "left": "boolean[]",
                  "right": "массив логических значений"
                }
              ],
              "xp": 14,
              "tip": "Тип X[] означает массив, состоящий из элементов типа X. Кортеж записывается как список типов в квадратных скобках, например, [T1, T2]."
            },
            {
              "id": "complex-array-fill",
              "type": "fill",
              "prompt": "Заполни объявление типа массива:\nts\nconst tags: ____ = ['ts', 'js'];\n",
              "placeholder": "тип",
              "answers": [
                "string[]"
              ],
              "xp": 10,
              "tip": "Для массива строк используется тип string[]."
            },
            {
              "id": "complex-tuple-index-match",
              "type": "match",
              "prompt": "Пусть tuple: [string, number]. Сопоставь обращение к элементу с его типом.",
              "left": [
                "tuple[0]",
                "tuple[1]"
              ],
              "right": [
                "string",
                "number"
              ],
              "pairs": [
                {
                  "left": "tuple[0]",
                  "right": "string"
                },
                {
                  "left": "tuple[1]",
                  "right": "number"
                }
              ],
              "xp": 12,
              "tip": "В кортеже [string, number] первый элемент (индекс 0) – строка, второй – число."
            },
            {
              "id": "complex-tuple-fill",
              "type": "fill",
              "prompt": "Заполни объявление типа кортежа:\nts\nlet pair: ____ = ['TS', 2025];\n",
              "placeholder": "тип",
              "answers": [
                "[string, number]"
              ],
              "xp": 10,
              "tip": "Кортеж с первым элементом string и вторым number записывается как [string, number]."
            },
            {
              "id": "complex-array-type-error",
              "type": "select-line",
              "prompt": "На какой строке ошибка: невалидный элемент массива?",
              "lines": [
                "let nums: number[] = [1, 2, '3'];"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Массив number[] должен содержать только числа.",
              "explanation": "Элемент '3' имеет тип string, а ожидается number."
            },
            {
              "id": "complex-tuple-type-error",
              "type": "select-line",
              "prompt": "На какой строке ошибка в типах элементов кортежа?",
              "lines": [
                "let tuple: [string, number] = [10, 'ten'];"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Первый элемент кортежа должен быть string, второй number (здесь перепутано).",
              "explanation": "Элемент 10 имеет тип number, а на первой позиции ожидается string."
            },
            {
              "id": "complex-tuple-vs-array",
              "type": "choice",
              "prompt": "Чем кортеж отличается от массива?",
              "options": [
                "Кортеж фиксированной длины и с определённым типом для каждой позиции, а массив может быть любой длины с элементами одного типа.",
                "Ничем: кортеж – это просто синоним массива.",
                "Массив фиксированной длины, а кортеж – переменной.",
                "В кортеже допускаются разные типы элементов, а в массиве – нет, даже в TS."
              ],
              "answer": "Кортеж фиксированной длины и с определённым типом для каждой позиции, а массив может быть любой длины с элементами одного типа.",
              "xp": 10,
              "tip": "Кортеж задаёт жёстко сколько элементов и какого типа каждый. Массив – список любого числа значений одного типа."
            },
            {
              "id": "complex-array-generic",
              "type": "choice",
              "prompt": "Как соотносятся записи string[] и Array<string>?",
              "options": [
                "Это два эквивалентных способа объявить массив строк.",
                "string[] означает массив, а Array<string> – особый объект.",
                "string[] корректно, а Array<string> – неверный синтаксис.",
                "string[] можно использовать только для примитивов, для остального – Array<T>."
              ],
              "answer": "Это два эквивалентных способа объявить массив строк.",
              "xp": 10,
              "tip": "string[] и Array<string> равнозначны. Вторая форма – с обобщённым типом – делает то же самое, что и сокращение с квадратными скобками."
            },
            {
              "id": "complex-union-array",
              "type": "choice",
              "prompt": "Как обозначить массив, элементы которого могут быть и строками, и числами?",
              "options": [
                "(string|number)[]",
                "string[] | number[]",
                "any[]",
                "Array<string>, Array<number>"
              ],
              "answer": "(string|number)[]",
              "xp": 10,
              "tip": "Чтобы тип элемента был или строкой, или числом, оберни объединение в скобки: (string|number)[] – массив, где каждый элемент может быть string или number."
            },
            {
              "id": "complex-tuple-length",
              "type": "choice",
              "prompt": "Сколько элементов может иметь массив типа [string, number]?",
              "options": [
                "Ровно 2 элемента.",
                "Любое количество.",
                "Не менее 2.",
                "Не более 2."
              ],
              "answer": "Ровно 2 элемента.",
              "xp": 10,
              "tip": "Кортеж [string, number] – строго два элемента: первый string, второй number."
            }
          ]
        },
        {
          "id": "lvl-union",
          "title": "Объединения (Union)",
          "goal": "Научиться использовать объединения типов (A | B).",
          "steps": [
            {
              "id": "complex-union-assign-error",
              "type": "select-line",
              "prompt": "На какой строке ошибка присваивания несовместимого типа?",
              "lines": [
                "let id: number | string = 123;",
                "id = 'abc';",
                "id = true;"
              ],
              "answerLine": 3,
              "xp": 12,
              "tip": "Union number|string не включает boolean.",
              "explanation": "Значение типа boolean не подходит типу number | string."
            },
            {
              "id": "complex-union-syntax",
              "type": "choice",
              "prompt": "Как обозначить тип, который может быть либо Cat, либо Dog?",
              "options": [
                "Cat | Dog",
                "Cat & Dog",
                "Cat || Dog",
                "Cat / Dog"
              ],
              "answer": "Cat | Dog",
              "xp": 10,
              "tip": "Для объединения типов используется вертикальная черта |."
            },
            {
              "id": "complex-union-ternary",
              "type": "choice",
              "prompt": "Какой тип получит выражение Math.random() < 0.5 ? 'yes' : 0?",
              "options": [
                "string | number",
                "string",
                "number",
                "any"
              ],
              "answer": "string | number",
              "xp": 10,
              "tip": "В тернарном операторе возвращаются либо строка 'yes', либо число 0. Итоговый тип объединяет эти варианты."
            },
            {
              "id": "complex-union-assign1",
              "type": "choice",
              "prompt": "Можно ли присвоить число переменной типа string | number?",
              "options": [
                "Да, число подходит, так как number входит в объединение.",
                "Нет, типы должны точно совпадать.",
                "Только если число литеральное (константное).",
                "Зависит от строгого режима."
              ],
              "answer": "Да, число подходит, так как number входит в объединение.",
              "xp": 10,
              "tip": "Если тип присваиваемого значения совпадает с одним из вариантов union-типа, присваивание разрешено."
            },
            {
              "id": "complex-union-assign2",
              "type": "choice",
              "prompt": "Можно ли присвоить переменной типа number значение переменной типа string | number?",
              "options": [
                "Нет, не гарантировано, что значение относится к числу.",
                "Да, ведь одно из объединенных значений — number.",
                "Да, но только при отключенных строгих проверках.",
                "Можно, компилятор лишь выдаст предупреждение."
              ],
              "answer": "Нет, не гарантировано, что значение относится к числу.",
              "xp": 10,
              "tip": "Нельзя напрямую присвоить значение типа string|number переменной типа number — оно может оказаться строкой."
            },
            {
              "id": "complex-union-values-match",
              "type": "match",
              "prompt": "Для типа number | string определи корректность следующих значений:",
              "left": [
                "42",
                "'hi'",
                "false"
              ],
              "right": [
                "подходит (number)",
                "подходит (string)",
                "не подходит"
              ],
              "pairs": [
                {
                  "left": "42",
                  "right": "подходит (number)"
                },
                {
                  "left": "'hi'",
                  "right": "подходит (string)"
                },
                {
                  "left": "false",
                  "right": "не подходит"
                }
              ],
              "xp": 12,
              "tip": "Тип number|string допускает числа (42), строки ('hi'), но не boolean (false)."
            },
            {
              "id": "complex-union-literals",
              "type": "choice",
              "prompt": "Если задано type Answer = 'yes' | 'no', какие значения может принимать переменная типа Answer?",
              "options": [
                "Только строки 'yes' или 'no'.",
                "Любую строку.",
                "Строки 'yes', 'no' или undefined.",
                "Только булевы значения."
              ],
              "answer": "Только строки 'yes' или 'no'.",
              "xp": 10,
              "tip": "Литеральный тип 'yes' | 'no' ограничивает значения именно этими строками."
            },
            {
              "id": "complex-union-count",
              "type": "choice",
              "prompt": "Сколько разных типов можно объединить с помощью |?",
              "options": [
                "Неограниченное количество.",
                "Не более двух.",
                "Не более трёх.",
                "Не более десяти."
              ],
              "answer": "Неограниченное количество.",
              "xp": 10,
              "tip": "Можно объединить сколько угодно вариантов: например, string|number|boolean|...."
            },
            {
              "id": "complex-union-order",
              "type": "order",
              "prompt": "Собери объявление типа X как объединения A и B.",
              "tokens": [
                "type",
                "X",
                "=",
                "A",
                "|",
                "B",
                ";"
              ],
              "solution": [
                "type",
                "X",
                "=",
                "A",
                "|",
                "B",
                ";"
              ],
              "xp": 12,
              "tip": "Type-алиас для объединения: type X = A | B;"
            },
            {
              "id": "complex-union-method-error",
              "type": "select-line",
              "prompt": "На какой строке ошибка использования union-типа?",
              "lines": [
                "let mix: number | string = '42';",
                "console.log(mix.toFixed(1));"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Нельзя вызывать метод, доступный не для всех вариантов number|string. Сначала нужно убедиться, что mix — число.",
              "explanation": "Без проверки типа нельзя вызвать toFixed, т.к. переменная может оказаться строкой."
            }
          ]
        },
        {
          "id": "lvl-intersection",
          "title": "Пересечения (Intersection)",
          "goal": "Научиться использовать пересечение типов (A & B).",
          "steps": [
            {
              "id": "complex-intersect-match",
              "type": "match",
              "prompt": "Сопоставь операции с их значением для типов:",
              "left": [
                "A & B",
                "A | B"
              ],
              "right": [
                "тип, требующий одновременно соответствовать и A, и B",
                "тип, допускающий значение либо типа A, либо типа B"
              ],
              "pairs": [
                {
                  "left": "A & B",
                  "right": "тип, требующий одновременно соответствовать и A, и B"
                },
                {
                  "left": "A | B",
                  "right": "тип, допускающий значение либо типа A, либо типа B"
                }
              ],
              "xp": 12,
              "tip": "A & B обозначает пересечение (должны выполняться оба типа), A | B – объединение (достаточно соответствовать одному из типов)."
            },
            {
              "id": "complex-intersect-syntax",
              "type": "choice",
              "prompt": "Как обозначить пересечение (intersection) типов A и B?",
              "options": [
                "A & B",
                "A | B",
                "A && B",
                "A + B"
              ],
              "answer": "A & B",
              "xp": 10,
              "tip": "Для пересечения используется амперсанд &."
            },
            {
              "id": "complex-intersect-obj",
              "type": "choice",
              "prompt": "Что должен содержать объект типа A & B?",
              "options": [
                "Все свойства, требуемые и типом A, и типом B.",
                "Только свойства типа A.",
                "Только свойства типа B.",
                "Любой из наборов свойств – либо A, либо B."
              ],
              "answer": "Все свойства, требуемые и типом A, и типом B.",
              "xp": 10,
              "tip": "Пересечение типов накладывает все требования сразу: объект должен удовлетворять обоим интерфейсам."
            },
            {
              "id": "complex-intersect-assign-error",
              "type": "select-line",
              "prompt": "На какой строке ошибка: объект не соответствует типу пересечения?",
              "lines": [
                "interface A { a: string; }",
                "interface B { b: number; }",
                "const obj: A & B = { a: 'X' };"
              ],
              "answerLine": 3,
              "xp": 12,
              "tip": "Объект типа A & B должен иметь свойства и a, и b.",
              "explanation": "Объект не соответствует B: отсутствует свойство b."
            },
            {
              "id": "complex-intersect-never",
              "type": "choice",
              "prompt": "Чему эквивалентен тип number & string?",
              "options": [
                "never",
                "string | number",
                "any",
                "string"
              ],
              "answer": "never",
              "xp": 10,
              "tip": "Значение не может быть одновременно числом и строкой, поэтому number & string — пустой (невозможный) тип never."
            },
            {
              "id": "complex-intersect-conflict",
              "type": "choice",
              "prompt": "Если интерфейс A требует поле x: number, а B требует поле x: string, каков тип A & B?",
              "options": [
                "never",
                "{ x: string | number }",
                "{ x: any }",
                "A | B"
              ],
              "answer": "never",
              "xp": 10,
              "tip": "Невозможно одновременно удовлетворить требование поля x как number и как string — пересечение даёт never."
            },
            {
              "id": "complex-intersect-count",
              "type": "choice",
              "prompt": "Сколько типов можно пересечь с помощью &?",
              "options": [
                "Любое количество.",
                "Не более двух.",
                "Не более трёх.",
                "Не более десяти."
              ],
              "answer": "Любое количество.",
              "xp": 10,
              "tip": "Пересечение может объединять несколько типов сразу: T1 & T2 & T3 и т.д."
            },
            {
              "id": "complex-intersect-fill",
              "type": "fill",
              "prompt": "Заполни объявление типа:\nts\ntype Mix = A ____ B;\n",
              "placeholder": "&",
              "answers": [
                "&"
              ],
              "xp": 10,
              "tip": "Используй & для пересечения типов."
            },
            {
              "id": "complex-intersect-any",
              "type": "choice",
              "prompt": "Чему эквивалентен тип any & string?",
              "options": [
                "string",
                "any",
                "unknown",
                "never"
              ],
              "answer": "string",
              "xp": 10,
              "tip": "Тип any при пересечении не накладывает ограничений, поэтому остаётся второй тип (string)."
            },
            {
              "id": "complex-intersect-order",
              "type": "order",
              "prompt": "Собери объявление типа X как пересечение A и B.",
              "tokens": [
                "type",
                "X",
                "=",
                "A",
                "&",
                "B",
                ";"
              ],
              "solution": [
                "type",
                "X",
                "=",
                "A",
                "&",
                "B",
                ";"
              ],
              "xp": 12,
              "tip": "Например: type X = A & B;"
            }
          ]
        },
        {
          "id": "lvl-literal-types",
          "title": "Литеральные и шаблонные типы",
          "goal": "Научиться задавать точные строковые/числовые значения и собирать шаблонные литеральные типы.",
          "steps": [
            {
              "id": "complex-literal-1",
              "type": "choice",
              "prompt": "Что описывает строковый литеральный тип 'pending'?",
              "options": [
                "Переменная может содержать только строку 'pending'.",
                "Переменная принимает любую строку.",
                "Переменная принимает только булевы значения.",
                "Это синоним типа never."
              ],
              "answer": "Переменная может содержать только строку 'pending'.",
              "xp": 10,
              "tip": "Литеральные типы фиксируют конкретное значение, а не весь базовый тип."
            },
            {
              "id": "complex-literal-2",
              "type": "select-line",
              "prompt": "На какой строке присваивается недопустимое литеральное значение?",
              "lines": [
                "type Status = 'success' | 'fail';",
                "const status: Status = 'loading';",
                "console.log(status);"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Union из литералов допускает только перечисленные варианты.",
              "explanation": "'loading' не входит в Status."
            },
            {
              "id": "complex-literal-3",
              "type": "match",
              "prompt": "Сопоставь запись типа с её описанием.",
              "left": [
                "'draft'",
                "42",
                "true",
                "`user:${number}`"
              ],
              "right": [
                "строковый литерал",
                "числовой литерал",
                "булевый литерал",
                "шаблонный строковый литерал"
              ],
              "pairs": [
                {
                  "left": "'draft'",
                  "right": "строковый литерал"
                },
                {
                  "left": "42",
                  "right": "числовой литерал"
                },
                {
                  "left": "true",
                  "right": "булевый литерал"
                },
                {
                  "left": "`user:${number}`",
                  "right": "шаблонный строковый литерал"
                }
              ],
              "xp": 14,
              "tip": "Шаблонный литерал использует интерполяцию ${...} внутри строки."
            },
            {
              "id": "complex-literal-4",
              "type": "fill",
              "prompt": "Объединение из конкретных литералов называется ____ типом.",
              "placeholder": "каким?",
              "answers": [
                "литеральным",
                "литеральным объединением"
              ],
              "xp": 10,
              "tip": "Например, type Direction = 'up' | 'down'."
            },
            {
              "id": "complex-literal-5",
              "type": "choice",
              "prompt": "Зачем применять as const при объявлении литеральных значений?",
              "options": [
                "Чтобы сохранить точные литеральные типы вместо обобщённых.",
                "Чтобы автоматически сериализовать объект в JSON.",
                "Чтобы сделать переменную доступной глобально.",
                "Чтобы включить строгий режим компилятора."
              ],
              "answer": "Чтобы сохранить точные литеральные типы вместо обобщённых.",
              "xp": 10,
              "tip": "as const делает свойства readonly и превращает значения в литералы."
            },
            {
              "id": "complex-literal-6",
              "type": "choice",
              "prompt": "Что описывает тип type Route = `/api/${string}`;?",
              "options": [
                "Любую строку, начинающуюся с /api/.",
                "Только строку '/api/'.",
                "Только строки с числом после /api/.",
                "Набор заранее фиксированных путей."
              ],
              "answer": "Любую строку, начинающуюся с /api/.",
              "xp": 10,
              "tip": "В шаблонном типе `${string}` означает \"любая подстрока\"."
            },
            {
              "id": "complex-literal-7",
              "type": "fill",
              "prompt": "Заполни тип шаблонного литерала для HTTP-кодов: type HttpCode = `HTTP_${____}`;",
              "placeholder": "тип",
              "answers": [
                "number"
              ],
              "xp": 10,
              "tip": "Используй number, чтобы разрешить любые числовые окончания."
            },
            {
              "id": "complex-literal-8",
              "type": "select-line",
              "prompt": "На какой строке значение не соответствует шаблонному литералу?",
              "lines": [
                "type Tag = `user-${string}`;",
                "const tag: Tag = 'order-1';",
                "console.log(tag);"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Шаблон требует префикс user-.",
              "explanation": "'order-1' не начинается с user-."
            },
            {
              "id": "complex-literal-9",
              "type": "choice",
              "prompt": "Чему равен тип переменной mode в примере: const settings = { mode: 'dark' } as const; const mode = settings.mode;?",
              "options": [
                "'dark'",
                "string",
                "'dark' | 'light'",
                "any"
              ],
              "answer": "'dark'",
              "xp": 10,
              "tip": "as const сохраняет литеральный тип для каждого свойства."
            },
            {
              "id": "complex-literal-10",
              "type": "order",
              "prompt": "Собери объявление типа SuccessCode, допускающего только статус-коды 200, 201 и 204.",
              "tokens": [
                "type",
                "SuccessCode",
                "=",
                "200",
                "|",
                "201",
                "|",
                "204",
                ";"
              ],
              "solution": [
                "type",
                "SuccessCode",
                "=",
                "200",
                "|",
                "201",
                "|",
                "204",
                ";"
              ],
              "xp": 12,
              "tip": "Литеральные объединения задаются оператором |."
            }
          ]
        },
        {
          "id": "lvl-type-vs-interface",
          "title": "Type vs Interface",
          "goal": "Разобраться в различиях между interface и type, чтобы осознанно выбирать инструмент описания структур.",
          "steps": [
            {
              "id": "complex-type-interface-1",
              "type": "choice",
              "prompt": "Какую уникальную возможность поддерживает interface?",
              "options": [
                "Декларативное слияние (можно объявлять одно имя несколько раз).",
                "Создание объединений с примитивами.",
                "Определение литеральных типов.",
                "Использование в качестве значения во время выполнения."
              ],
              "answer": "Декларативное слияние (можно объявлять одно имя несколько раз).",
              "xp": 10,
              "tip": "interface складывает определения, а type нужно объявлять ровно один раз."
            },
            {
              "id": "complex-type-interface-2",
              "type": "choice",
              "prompt": "Как задать тип, допускающий либо строку, либо число?",
              "options": [
                "type Value = string | number;",
                "interface Value { string | number }",
                "interface Value extends string, number { }",
                "interface Value = string | number;"
              ],
              "answer": "type Value = string | number;",
              "xp": 10,
              "tip": "Union с примитивами можно описать только через type."
            },
            {
              "id": "complex-type-interface-3",
              "type": "match",
              "prompt": "Сопоставь задачу с конструкцией, которая решает её напрямую.",
              "left": [
                "Создать объединение string | number",
                "Добавить новое поле к существующему имени типа",
                "Описать сигнатуру функции"
              ],
              "right": [
                "type alias",
                "interface",
                "оба варианта"
              ],
              "pairs": [
                {
                  "left": "Создать объединение string | number",
                  "right": "type alias"
                },
                {
                  "left": "Добавить новое поле к существующему имени типа",
                  "right": "interface"
                },
                {
                  "left": "Описать сигнатуру функции",
                  "right": "оба варианта"
                }
              ],
              "xp": 14,
              "tip": "И interface, и type могут описывать функции, но union — только через type."
            },
            {
              "id": "complex-type-interface-4",
              "type": "select-line",
              "prompt": "На какой строке попытка повторно объявить type приведёт к ошибке?",
              "lines": [
                "type Config = { url: string; };",
                "type Config = { token: string; };",
                "const cfg: Config = { url: 'x', token: 'y' };"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "type нельзя объявлять дважды под одним именем.",
              "explanation": "Повторное объявление type Config запрещено."
            },
            {
              "id": "complex-type-interface-5",
              "type": "fill",
              "prompt": "Повторные объявления interface автоматически объединяются благодаря механизму ____.",
              "placeholder": "как называется?",
              "answers": [
                "merging",
                "слияния"
              ],
              "xp": 10,
              "tip": "Declaration merging позволяет расширять интерфейсы частями."
            },
            {
              "id": "complex-type-interface-6",
              "type": "choice",
              "prompt": "Может ли класс реализовать (implements) type-алиас, описывающий объектную структуру?",
              "options": [
                "Да, если алиас раскрывается в объектный тип.",
                "Нет, implements работает только с interface.",
                "Только при включённом experimentalDecorators.",
                "Только если алиас объявлен в том же файле."
              ],
              "answer": "Да, если алиас раскрывается в объектный тип.",
              "xp": 10,
              "tip": "Class может implement любой объектный тип, не важно interface или type."
            },
            {
              "id": "complex-type-interface-7",
              "type": "select-line",
              "prompt": "На какой строке попытка расширить union через interface приводит к ошибке?",
              "lines": [
                "type Identifiable = { id: string } | { slug: string };",
                "interface Item extends Identifiable {}"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "interface может расширять только объектные типы, но не union из нескольких форм.",
              "explanation": "Identifiable — объединение, поэтому его нельзя использовать в extends интерфейса."
            },
            {
              "id": "complex-type-interface-8",
              "type": "choice",
              "prompt": "Что выбрать для описания кортежа [number, string]?",
              "options": [
                "type Tuple = [number, string];",
                "interface Tuple { [0]: number; [1]: string; }",
                "interface Tuple extends Array<number | string> { }",
                "Любой из вариантов без разницы."
              ],
              "answer": "type Tuple = [number, string];",
              "xp": 10,
              "tip": "Кортежи естественно описываются через type alias."
            },
            {
              "id": "complex-type-interface-9",
              "type": "fill",
              "prompt": "Чтобы создать новый интерфейс на базе существующего, используй ключевое слово ____.",
              "placeholder": "ключевое слово",
              "answers": [
                "extends"
              ],
              "xp": 10,
              "tip": "interface Child extends Parent { ... } — типичный пример."
            },
            {
              "id": "complex-type-interface-10",
              "type": "choice",
              "prompt": "В каком случае interface обычно предпочтительнее type?",
              "options": [
                "Когда нужно постепенно наращивать API (добавлять поля в разных файлах).",
                "Когда требуется описать union примитивов.",
                "Когда нужно задать тип для typeof оператора.",
                "Когда необходимо объявить литеральный тип."
              ],
              "answer": "Когда нужно постепенно наращивать API (добавлять поля в разных файлах).",
              "xp": 10,
              "tip": "Declaration merging и расширения делают interface удобным для публичных API."
            }
          ]
        }
      ]
    },
    {
      "id": "unit-generics",
      "title": "Generics и условные типы",
      "description": "Обобщённые типы, ограничения, условные конструкции и ключевое слово infer.",
      "accent": "#F97316",
      "levels": [
        {
          "id": "lvl-generic-constraints",
          "title": "Ограничения дженериков",
          "goal": "Научиться использовать extends, keyof и другие ограничения для параметров типа.",
          "steps": [
            {
              "id": "generics-constraints-1",
              "type": "choice",
              "prompt": "Зачем добавлять ограничение T extends { id: string } в обобщённой функции?",
              "options": [
                "Чтобы гарантировать наличие свойства id у каждого аргумента.",
                "Чтобы запретить использование функции с числами.",
                "Чтобы автоматически сериализовать объект.",
                "Чтобы функция работала только в среде Node.js."
              ],
              "answer": "Чтобы гарантировать наличие свойства id у каждого аргумента.",
              "xp": 10,
              "tip": "Ограничение описывает минимальную структуру обобщённого типа."
            },
            {
              "id": "generics-constraints-2",
              "type": "select-line",
              "prompt": "На какой строке нужно добавить ограничение, чтобы избежать ошибки?",
              "lines": [
                "function getName<T>(entity: T) {",
                "  return entity.name.toUpperCase();",
                "}"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Параметр T должен расширять объект с полем name.",
              "explanation": "Без ограничения компилятор не знает о существовании свойства name."
            },
            {
              "id": "generics-constraints-3",
              "type": "fill",
              "prompt": "Заполни ограничение: function logLength<T extends ____>(value: T) { return value.length; }",
              "placeholder": "тип",
              "answers": [
                "{ length: number }"
              ],
              "xp": 10,
              "tip": "Если тип гарантирует наличие length, можно безопасно обратиться к свойству."
            },
            {
              "id": "generics-constraints-4",
              "type": "match",
              "prompt": "Сопоставь обобщённую функцию с тем, что гарантирует её ограничение.",
              "left": [
                "function pick<T extends object, K extends keyof T>(obj: T, key: K)",
                "function first<T extends any[]>(list: T)",
                "function parse<T extends string | number>(value: T)"
              ],
              "right": [
                "ключ K точно существует в obj",
                "T имеет индекс и длину массива",
                "T ограничен числами или строками"
              ],
              "pairs": [
                {
                  "left": "function pick<T extends object, K extends keyof T>(obj: T, key: K)",
                  "right": "ключ K точно существует в obj"
                },
                {
                  "left": "function first<T extends any[]>(list: T)",
                  "right": "T имеет индекс и длину массива"
                },
                {
                  "left": "function parse<T extends string | number>(value: T)",
                  "right": "T ограничен числами или строками"
                }
              ],
              "xp": 14,
              "tip": "extends помогает описать минимальный набор возможностей типа."
            },
            {
              "id": "generics-constraints-5",
              "type": "choice",
              "prompt": "Как ограничить обобщённый тип T только массивами чисел?",
              "options": [
                "Написать T extends number[]",
                "Написать T extends Array<any>",
                "Использовать условный тип",
                "Это невозможно в TypeScript"
              ],
              "answer": "Написать T extends number[]",
              "xp": 10,
              "tip": "Можно комбинировать extends с нужной структурой массива."
            },
            {
              "id": "generics-constraints-6",
              "type": "choice",
              "prompt": "Зачем объявлять параметр K extends keyof T?",
              "options": [
                "Чтобы ключ всегда принадлежал объекту T.",
                "Чтобы запретить использование строковых ключей.",
                "Чтобы автоматически сериализовать ключ.",
                "Чтобы сделать тип независимым от T."
              ],
              "answer": "Чтобы ключ всегда принадлежал объекту T.",
              "xp": 10,
              "tip": "keyof T превращает имена свойств в объединение литералов."
            },
            {
              "id": "generics-constraints-7",
              "type": "select-line",
              "prompt": "На какой строке объект не удовлетворяет ограничению?",
              "lines": [
                "function prop<T extends { id: number }>(value: T) {",
                "  return value.id;",
                "}",
                "prop({ slug: 'post' });"
              ],
              "answerLine": 4,
              "xp": 12,
              "tip": "Аргумент обязан содержать поле id.",
              "explanation": "Объект без id не удовлетворяет ограничению T extends { id: number }."
            },
            {
              "id": "generics-constraints-8",
              "type": "fill",
              "prompt": "Заполни ограничение, чтобы функция принимала только промисы: function unwrap<T extends ____>(promise: T) { return promise.then(v => v); }",
              "placeholder": "тип",
              "answers": [
                "Promise<unknown>",
                "Promise<any>"
              ],
              "xp": 10,
              "tip": "Когда параметр должен иметь метод then, ограничь его интерфейсом промиса."
            },
            {
              "id": "generics-constraints-9",
              "type": "choice",
              "prompt": "Что произойдёт, если обратиться к value.id без ограничения на T?",
              "options": [
                "Компилятор сообщит, что у T может не быть свойства id.",
                "TypeScript автоматически добавит поле id.",
                "Код не скомпилируется только в режиме strictNullChecks.",
                "Ничего — свойство появится в рантайме."
              ],
              "answer": "Компилятор сообщит, что у T может не быть свойства id.",
              "xp": 10,
              "tip": "Без ограничения T считается неизвестным типом, и доступ к свойствам запрещён."
            },
            {
              "id": "generics-constraints-10",
              "type": "order",
              "prompt": "Упорядочи шаги при проектировании ограничения для дженерика.",
              "tokens": [
                "выделить обязательные свойства",
                "записать ограничение через extends",
                "использовать свойства внутри функции",
                "вызвать функцию с подходящими значениями"
              ],
              "solution": [
                "выделить обязательные свойства",
                "записать ограничение через extends",
                "использовать свойства внутри функции",
                "вызвать функцию с подходящими значениями"
              ],
              "xp": 12,
              "tip": "Сначала формулируем контракт, затем применяем его к коду."
            }
          ]
        },
        {
          "id": "lvl-generic-conditional",
          "title": "Условные типы с extends",
          "goal": "Понять синтаксис T extends U ? X : Y и распределение по объединениям.",
          "steps": [
            {
              "id": "generics-conditional-1",
              "type": "choice",
              "prompt": "Чему равен тип IsNumber<string>, если type IsNumber<T> = T extends number ? 'num' : 'other';?",
              "options": [
                "'num'",
                "'other'",
                "number",
                "never"
              ],
              "answer": "'other'",
              "xp": 10,
              "tip": "string не расширяет number, поэтому выбирается ветка else."
            },
            {
              "id": "generics-conditional-2",
              "type": "choice",
              "prompt": "Чему равен тип NonNullable<string | undefined>? (type NonNullable<T> = T extends null | undefined ? never : T;)",
              "options": [
                "string",
                "string | undefined",
                "never",
                "undefined"
              ],
              "answer": "string",
              "xp": 10,
              "tip": "Conditional тип применился к каждому члену объединения и убрал undefined."
            },
            {
              "id": "generics-conditional-3",
              "type": "select-line",
              "prompt": "На какой строке тип становится never и приводит к ошибке?",
              "lines": [
                "type NonEmpty<T extends string> = T extends '' ? never : T;",
                "const slug: NonEmpty<''> = '';"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Если условие выполняется, результатом становится never.",
              "explanation": "NonEmpty<''> равен never, поэтому нельзя объявить переменную этого типа."
            },
            {
              "id": "generics-conditional-4",
              "type": "match",
              "prompt": "Сопоставь условный тип с его назначением.",
              "left": [
                "type ToArray<T> = T extends any ? T[] : never",
                "type ElementType<T> = T extends any[] ? T[number] : T",
                "type EnsurePromise<T> = T extends Promise<unknown> ? T : Promise<T>"
              ],
              "right": [
                "оборачивает каждый тип в массив",
                "возвращает тип элемента массива",
                "гарантирует, что результат — промис"
              ],
              "pairs": [
                {
                  "left": "type ToArray<T> = T extends any ? T[] : never",
                  "right": "оборачивает каждый тип в массив"
                },
                {
                  "left": "type ElementType<T> = T extends any[] ? T[number] : T",
                  "right": "возвращает тип элемента массива"
                },
                {
                  "left": "type EnsurePromise<T> = T extends Promise<unknown> ? T : Promise<T>",
                  "right": "гарантирует, что результат — промис"
                }
              ],
              "xp": 14,
              "tip": "Conditional типы позволяют выражать ветвления на уровне типов."
            },
            {
              "id": "generics-conditional-5",
              "type": "fill",
              "prompt": "Допиши условие: type ReadonlyIfObject<T> = T extends ____ ? Readonly<T> : T;",
              "placeholder": "тип",
              "answers": [
                "object"
              ],
              "xp": 10,
              "tip": "Эта конструкция оставляет примитивы без изменений, а объекты делает Readonly."
            },
            {
              "id": "generics-conditional-6",
              "type": "choice",
              "prompt": "Что вернёт type Box<T> = T extends number ? number[] : string[] для T = number | string?",
              "options": [
                "number[] | string[]",
                "string[]",
                "number[]",
                "never"
              ],
              "answer": "number[] | string[]",
              "xp": 10,
              "tip": "Conditional тип распределяется по объединению и вычисляет каждую ветку отдельно."
            },
            {
              "id": "generics-conditional-7",
              "type": "choice",
              "prompt": "Чему равен тип Truthy<0 | 'hi'>, если type Truthy<T> = T extends false | 0 | '' | null | undefined ? false : true;?",
              "options": [
                "false | true",
                "true",
                "false",
                "never"
              ],
              "answer": "false | true",
              "xp": 10,
              "tip": "Каждый элемент объединения проверяется отдельно, поэтому результат — объединение ответов."
            },
            {
              "id": "generics-conditional-8",
              "type": "select-line",
              "prompt": "На какой строке conditional тип возвращает never из-за отсутствия id?",
              "lines": [
                "type WithId<T> = T extends { id: string } ? T : never;",
                "const item: WithId<{ slug: string }> = { slug: 'post' };"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Если условие не выполняется, тип становится never.",
              "explanation": "Объект без id не удовлетворяет условию, поэтому типом становится never."
            },
            {
              "id": "generics-conditional-9",
              "type": "fill",
              "prompt": "Conditional тип записывается как T extends U ? X : ____.",
              "placeholder": "что?",
              "answers": [
                "Y",
                "Else"
              ],
              "xp": 10,
              "tip": "После двоеточия указывается ветка \"иначе\"."
            },
            {
              "id": "generics-conditional-10",
              "type": "order",
              "prompt": "Собери объявление типа Maybe<T>, убирающего null и undefined.",
              "tokens": [
                "type",
                "Maybe",
                "<T>",
                "=",
                "T",
                "extends",
                "null",
                "|",
                "undefined",
                "?",
                "never",
                ":",
                "T",
                ";"
              ],
              "solution": [
                "type",
                "Maybe",
                "<T>",
                "=",
                "T",
                "extends",
                "null",
                "|",
                "undefined",
                "?",
                "never",
                ":",
                "T",
                ";"
              ],
              "xp": 12,
              "tip": "Conditional типы читаются как тернарный оператор для типов."
            }
          ]
        },
        {
          "id": "lvl-generic-infer",
          "title": "Условные типы с infer",
          "goal": "Научиться извлекать вложенные типы с помощью ключевого слова infer.",
          "steps": [
            {
              "id": "generics-infer-1",
              "type": "choice",
              "prompt": "Что делает ключевое слово infer в условном типе?",
              "options": [
                "Захватывает неизвестный тип и даёт ему имя для дальнейшего использования.",
                "Создаёт новый тип any.",
                "Выполняет функцию во время компиляции.",
                "Заменяет extends на implements."
              ],
              "answer": "Захватывает неизвестный тип и даёт ему имя для дальнейшего использования.",
              "xp": 10,
              "tip": "infer объявляет временный параметр внутри условного типа."
            },
            {
              "id": "generics-infer-2",
              "type": "choice",
              "prompt": "Чему равен тип Element<string[]> для объявления type Element<T> = T extends (infer U)[] ? U : T;?",
              "options": [
                "string",
                "string[]",
                "any",
                "never"
              ],
              "answer": "string",
              "xp": 10,
              "tip": "infer U вытаскивает тип элемента массива."
            },
            {
              "id": "generics-infer-3",
              "type": "match",
              "prompt": "Сопоставь шаблон с тем, какой тип он извлекает.",
              "left": [
                "type Return<T> = T extends (...args: any[]) => infer R ? R : never",
                "type First<T> = T extends [infer F, ...any[]] ? F : never",
                "type PromiseValue<T> = T extends Promise<infer U> ? U : T"
              ],
              "right": [
                "возвращаемое значение функции",
                "первый элемент кортежа",
                "значение внутри промиса"
              ],
              "pairs": [
                {
                  "left": "type Return<T> = T extends (...args: any[]) => infer R ? R : never",
                  "right": "возвращаемое значение функции"
                },
                {
                  "left": "type First<T> = T extends [infer F, ...any[]] ? F : never",
                  "right": "первый элемент кортежа"
                },
                {
                  "left": "type PromiseValue<T> = T extends Promise<infer U> ? U : T",
                  "right": "значение внутри промиса"
                }
              ],
              "xp": 14,
              "tip": "infer позволяет присвоить имя части шаблона и переиспользовать его."
            },
            {
              "id": "generics-infer-4",
              "type": "select-line",
              "prompt": "На какой строке значение не соответствует типу, извлечённому через infer?",
              "lines": [
                "type Return<T> = T extends () => infer R ? R : never;",
                "const value: Return<() => number> = 'oops';"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Return<() => number> равен number.",
              "explanation": "Строка не совместима с number."
            },
            {
              "id": "generics-infer-5",
              "type": "fill",
              "prompt": "Заполни имя извлечённого остатка: type Tail<T extends any[]> = T extends [any, ...infer ____] ? ____ : never;",
              "placeholder": "имя",
              "answers": [
                "Rest"
              ],
              "xp": 10,
              "tip": "Rest используется дважды: сначала объявляется, потом возвращается."
            },
            {
              "id": "generics-infer-6",
              "type": "choice",
              "prompt": "Как получить тип первого аргумента функции с помощью infer?",
              "options": [
                "type FirstArg<T> = T extends (infer A, ...any[]) ? A : never;",
                "type FirstArg<T> = T extends (...args: [infer A, ...any[]]) => any ? A : never;",
                "type FirstArg<T> = infer T[0];",
                "Это невозможно."
              ],
              "answer": "type FirstArg<T> = T extends (...args: [infer A, ...any[]]) => any ? A : never;",
              "xp": 10,
              "tip": "Аргументы функции описываются как кортеж, внутри которого можно применить infer."
            },
            {
              "id": "generics-infer-7",
              "type": "select-line",
              "prompt": "На какой строке неверно используется результат типа UnboxPromise?",
              "lines": [
                "type UnboxPromise<T> = T extends Promise<infer U> ? U : T;",
                "const data: UnboxPromise<Promise<string>> = 42;"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "UnboxPromise<Promise<string>> равен string.",
              "explanation": "Число нельзя присвоить строковому типу."
            },
            {
              "id": "generics-infer-8",
              "type": "fill",
              "prompt": "В записи T extends Promise<infer Value> слово ____ объявляет новый тип Value.",
              "placeholder": "ключевое слово",
              "answers": [
                "infer"
              ],
              "xp": 10,
              "tip": "infer всегда идёт перед именем выводимого типа."
            },
            {
              "id": "generics-infer-9",
              "type": "choice",
              "prompt": "Чему равен тип Flatten<number[][]>, если type Flatten<T> = T extends Array<infer U> ? Flatten<U> : T;?",
              "options": [
                "number",
                "number[]",
                "any",
                "never"
              ],
              "answer": "number",
              "xp": 10,
              "tip": "Тип рекурсивно разворачивает массивы, пока не останется примитив."
            },
            {
              "id": "generics-infer-10",
              "type": "order",
              "prompt": "Упорядочи шаги при создании условного типа с infer.",
              "tokens": [
                "задать форму шаблона",
                "вставить слово infer и имя типа",
                "использовать извлечённый тип в результате",
                "обработать альтернативную ветку"
              ],
              "solution": [
                "задать форму шаблона",
                "вставить слово infer и имя типа",
                "использовать извлечённый тип в результате",
                "обработать альтернативную ветку"
              ],
              "xp": 12,
              "tip": "Главное — сначала описать паттерн, к которому будет применяться infer."
            }
          ]
        }
      ]
    },
    {
      "id": "unit-narrowing",
      "title": "Narrowing и type guards",
      "description": "Как сужать объединения стандартными проверками и писать собственные защитники типов.",
      "accent": "#EC4899",
      "levels": [
        {
          "id": "lvl-narrowing-standard",
          "title": "Стандартные способы сужения",
          "goal": "Научиться использовать typeof, instanceof, проверку на null и другие приёмы для сужения типов.",
          "steps": [
            {
              "id": "narrowing-standard-1",
              "type": "choice",
              "prompt": "Какой оператор позволяет сужать типы примитивов?",
              "options": [
                "typeof",
                "instanceof",
                "in",
                "as"
              ],
              "answer": "typeof",
              "xp": 10,
              "tip": "typeof работает с примитивными типами: string, number, boolean и т.д."
            },
            {
              "id": "narrowing-standard-2",
              "type": "select-line",
              "prompt": "На какой строке тип переменной value сужается к string?",
              "lines": [
                "function process(value: string | number) {",
                "  if (typeof value === 'string') {",
                "    console.log(value.toUpperCase());",
                "  }",
                "}"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Проверка typeof сужает тип внутри блока if.",
              "explanation": "Внутри if значение value гарантированно является строкой."
            },
            {
              "id": "narrowing-standard-3",
              "type": "fill",
              "prompt": "Заполни пропуск: if (obj ____ 'prop') { console.log(obj.prop); }",
              "placeholder": "оператор",
              "answers": [
                "in"
              ],
              "xp": 10,
              "tip": "Оператор in проверяет наличие свойства в объекте."
            },
            {
              "id": "narrowing-standard-4",
              "type": "choice",
              "prompt": "Какой оператор используется для сужения типов классов?",
              "options": [
                "instanceof",
                "typeof",
                "as",
                "`template string`"
              ],
              "answer": "instanceof",
              "xp": 10,
              "tip": "instanceof проверяет принадлежность объекта к классу."
            },
            {
              "id": "narrowing-standard-5",
              "type": "choice",
              "prompt": "Как одной проверкой исключить и null, и undefined перед доступом к свойству?",
              "options": [
                "if (value != null) { ... }",
                "if (typeof value === 'object') { ... }",
                "if (value !== 0) { ... }",
                "if (value as object) { ... }"
              ],
              "answer": "if (value != null) { ... }",
              "xp": 10,
              "tip": "Сравнение != одновременно исключает null и undefined, сохраняя остальные значения.",
              "explanation": "Проверка value != null отсекает null и undefined, поэтому дальше можно безопасно читать поля."
            },
            {
              "id": "narrowing-standard-6",
              "type": "select-line",
              "prompt": "На какой строке значение input сужается к Date?",
              "lines": [
                "function getTimestamp(input: string | Date) {",
                "  if (input instanceof Date) {",
                "    return input.getTime();",
                "  }",
                "  return Date.parse(input);",
                "}"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "instanceof проверяет прототип и подходит для классов и встроенных объектов вроде Date.",
              "explanation": "После проверки instanceof компилятор рассматривает input как Date внутри блока."
            },
            {
              "id": "narrowing-standard-7",
              "type": "fill",
              "prompt": "Заполни проверку: if (____(value)) { value.push(42); }",
              "placeholder": "функция",
              "answers": [
                "Array.isArray"
              ],
              "xp": 10,
              "tip": "Array.isArray — встроенная функция, которая сообщает TypeScript, что значение точно массив."
            },
            {
              "id": "narrowing-standard-8",
              "type": "match",
              "prompt": "Сопоставь задачу и подход к сужению типа.",
              "left": [
                "Проверить, что переменная — строка",
                "Убедиться, что у объекта есть поле save",
                "Понять, что значение — экземпляр Error",
                "Отсечь null/undefined перед чтением user.id"
              ],
              "right": [
                "typeof value === 'string'",
                "'save' in value",
                "value instanceof Error",
                "value != null"
              ],
              "pairs": [
                {
                  "left": "Проверить, что переменная — строка",
                  "right": "typeof value === 'string'"
                },
                {
                  "left": "Убедиться, что у объекта есть поле save",
                  "right": "'save' in value"
                },
                {
                  "left": "Понять, что значение — экземпляр Error",
                  "right": "value instanceof Error"
                },
                {
                  "left": "Отсечь null/undefined перед чтением user.id",
                  "right": "value != null"
                }
              ],
              "xp": 14,
              "tip": "У каждого приёма своя область: typeof — для примитивов, instanceof — для классов, in — для структуры объекта."
            },
            {
              "id": "narrowing-standard-9",
              "type": "select-line",
              "prompt": "На какой строке user сужается до объекта с полем name?",
              "lines": [
                "function printName(user?: { name: string } | null) {",
                "  if (!user) {",
                "    return;",
                "  }",
                "  console.log(user.name);",
                "}"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Проверка !user отбрасывает null и undefined, оставляя только объект.",
              "explanation": "После раннего возврата оставшийся код работает с user как с { name: string }."
            },
            {
              "id": "narrowing-standard-10",
              "type": "order",
              "prompt": "Собери фрагмент, который вызывает метод toFixed только у чисел.",
              "tokens": [
                "if",
                "(typeof",
                "value",
                "===",
                "'number')",
                "{",
                "value.toFixed(2);",
                "}"
              ],
              "solution": [
                "if",
                "(typeof",
                "value",
                "===",
                "'number')",
                "{",
                "value.toFixed(2);",
                "}"
              ],
              "xp": 12,
              "tip": "Сначала выполняется проверка typeof, и только внутри блока вызывается числовой метод."
            }
          ]
        }
      ]
    },
    {
      "id": "unit-transform",
      "title": "Преобразование и метаоператоры",
      "description": "Type assertions, оператор satisfies, typeof/keyof и отличия object/Object/{}.",
      "accent": "#EF4444",
      "levels": [
        {
          "id": "lvl-type-assertions",
          "title": "Type assertions и satisfies",
          "goal": "Научиться безопасно использовать as, satisfies и const assertion.",
          "steps": [
            {
              "id": "transform-assert-1",
              "type": "choice",
              "prompt": "Что делает оператор type assertion (as)?",
              "options": [
                "Сообщает компилятору, как рассматривать выражение по типу.",
                "Изменяет значение во время выполнения.",
                "Добавляет новое свойство к объекту.",
                "Запускает дополнительный рантайм-проверки."
              ],
              "answer": "Сообщает компилятору, как рассматривать выражение по типу.",
              "xp": 10,
              "tip": "Type assertion влияет только на типовую систему и не меняет значение."
            },
            {
              "id": "transform-assert-2",
              "type": "choice",
              "prompt": "Чем type assertion отличается от приведения типов в других языках?",
              "options": [
                "Он не выполняет преобразование значения, а лишь меняет взгляд компилятора.",
                "Он быстрее, потому что использует WebAssembly.",
                "Он может работать только с числами.",
                "Он всегда приводит к ошибке во время выполнения."
              ],
              "answer": "Он не выполняет преобразование значения, а лишь меняет взгляд компилятора.",
              "xp": 10,
              "tip": "Если значение не подходит, ошибка проявится уже в рантайме."
            },
            {
              "id": "transform-assert-3",
              "type": "select-line",
              "prompt": "На какой строке некорректно используется as для преобразования?",
              "lines": [
                "const value = '42';",
                "const num = value as number;",
                "console.log(num.toFixed(2));"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Type assertion не превращает строку в число — потребуется явное преобразование.",
              "explanation": "Значение остаётся строкой, поэтому вызов toFixed упадёт."
            },
            {
              "id": "transform-assert-4",
              "type": "match",
              "prompt": "Выбери подходящий инструмент под задачу.",
              "left": [
                "Уточнить результат querySelector",
                "Проверить объект на соответствие интерфейсу без расширения его типа",
                "Сохранить литеральные значения и сделать поля readonly"
              ],
              "right": [
                "as HTMLElement",
                "satisfies",
                "as const"
              ],
              "pairs": [
                {
                  "left": "Уточнить результат querySelector",
                  "right": "as HTMLElement"
                },
                {
                  "left": "Проверить объект на соответствие интерфейсу без расширения его типа",
                  "right": "satisfies"
                },
                {
                  "left": "Сохранить литеральные значения и сделать поля readonly",
                  "right": "as const"
                }
              ],
              "xp": 14,
              "tip": "Выбирай инструмент в зависимости от задачи — не всё решается as."
            },
            {
              "id": "transform-assert-5",
              "type": "fill",
              "prompt": "const config = { baseUrl: '/api', timeout: 1000 } ____ ApiConfig;",
              "placeholder": "оператор",
              "answers": [
                "satisfies"
              ],
              "xp": 10,
              "tip": "satisfies проверяет объект на соответствие типу и при этом не расширяет его."
            },
            {
              "id": "transform-assert-6",
              "type": "choice",
              "prompt": "Чем satisfies отличается от as?",
              "options": [
                "satisfies проверяет соответствие и не позволяет опустить поля, а as просто заставляет компилятор поверить разработчику.",
                "Они полностью эквивалентны.",
                "satisfies работает только для чисел.",
                "as доступен только в JSX."
              ],
              "answer": "satisfies проверяет соответствие и не позволяет опустить поля, а as просто заставляет компилятор поверить разработчику.",
              "xp": 10,
              "tip": "satisfies полезен для проверки литеральных объектов."
            },
            {
              "id": "transform-assert-7",
              "type": "select-line",
              "prompt": "На какой строке станет видно, что объект request не соответствует интерфейсу?",
              "lines": [
                "interface Request { url: string; method: 'GET' | 'POST'; }",
                "const request = {",
                "  url: '/ping'",
                "} satisfies Request;"
              ],
              "answerLine": 4,
              "xp": 12,
              "tip": "satisfies подсветит отсутствующее свойство method.",
              "explanation": "Интерфейс требует поле method, но его нет."
            },
            {
              "id": "transform-assert-8",
              "type": "choice",
              "prompt": "Когда допустимо использовать конструкцию value as unknown as Target?",
              "options": [
                "Только в крайних случаях, когда других вариантов нет и разработчик берет ответственность.",
                "Всегда, это нормальная практика.",
                "Только в тестах.",
                "Только при использовании JSX."
              ],
              "answer": "Только в крайних случаях, когда других вариантов нет и разработчик берет ответственность.",
              "xp": 10,
              "tip": "Двойная assertion отключает проверки — лучше найти более безопасное решение."
            },
            {
              "id": "transform-assert-9",
              "type": "fill",
              "prompt": "Type assertion записывается как выражение ____ ЦелевойТип.",
              "placeholder": "оператор",
              "answers": [
                "as"
              ],
              "xp": 10,
              "tip": "Например: value as HTMLElement."
            },
            {
              "id": "transform-assert-10",
              "type": "order",
              "prompt": "Упорядочи шаги ответственного использования type assertion.",
              "tokens": [
                "убедиться, что значение действительно подходит",
                "написать утверждение через as/satisfies",
                "прокомментировать, почему это безопасно",
                "перепроверить код-вызывающий"
              ],
              "solution": [
                "убедиться, что значение действительно подходит",
                "написать утверждение через as/satisfies",
                "прокомментировать, почему это безопасно",
                "перепроверить код-вызывающий"
              ],
              "xp": 12,
              "tip": "Assertion — крайняя мера, важно зафиксировать причину."
            }
          ]
        },
        {
          "id": "lvl-typeof-keyof",
          "title": "typeof, keyof и object",
          "goal": "Использовать оператор typeof для типов, получать ключи через keyof и избегать ловушек object/Object/{}.",
          "steps": [
            {
              "id": "transform-meta-1",
              "type": "choice",
              "prompt": "Что делает оператор typeof на уровне типов?",
              "options": [
                "Извлекает тип у уже объявленного значения.",
                "Возвращает строковое значение типа во время выполнения.",
                "Создаёт новый объект.",
                "Работает только внутри классов."
              ],
              "answer": "Извлекает тип у уже объявленного значения.",
              "xp": 10,
              "tip": "type Props = typeof config; позволяет переиспользовать форму объекта."
            },
            {
              "id": "transform-meta-2",
              "type": "fill",
              "prompt": "type Config = ____ settings; // получить тип переменной settings",
              "placeholder": "оператор",
              "answers": [
                "typeof"
              ],
              "xp": 10,
              "tip": "typeof работает и в выражениях типов."
            },
            {
              "id": "transform-meta-3",
              "type": "choice",
              "prompt": "В чём разница между typeof в коде и typeof в типах?",
              "options": [
                "В коде — это оператор, возвращающий строку, а в типах — синтаксис для извлечения типа.",
                "Разницы нет, это одно и то же.",
                "В типах typeof запрещён.",
                "В коде typeof возвращает boolean."
              ],
              "answer": "В коде — это оператор, возвращающий строку, а в типах — синтаксис для извлечения типа.",
              "xp": 10,
              "tip": "Контекст (code vs type) определяется местом использования."
            },
            {
              "id": "transform-meta-4",
              "type": "match",
              "prompt": "Сопоставь тип с его значением.",
              "left": [
                "object",
                "Object",
                "{}"
              ],
              "right": [
                "любой непримитив (не включает числа, строки и т.п.)",
                "почти все значения кроме null/undefined",
                "технический верхний тип (разрешает всё, кроме null/undefined)"
              ],
              "pairs": [
                {
                  "left": "object",
                  "right": "любой непримитив (не включает числа, строки и т.п.)"
                },
                {
                  "left": "Object",
                  "right": "почти все значения кроме null/undefined"
                },
                {
                  "left": "{}",
                  "right": "технический верхний тип (разрешает всё, кроме null/undefined)"
                }
              ],
              "xp": 14,
              "tip": "Не путай object с Object: второй включает примитивы."
            },
            {
              "id": "transform-meta-5",
              "type": "select-line",
              "prompt": "На какой строке неверно использовать тип Object?",
              "lines": [
                "let value: Object = 42;",
                "value.toFixed(2);"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Тип Object не гарантирует наличие числовых методов.",
              "explanation": "toFixed определён у number, но не у Object."
            },
            {
              "id": "transform-meta-6",
              "type": "choice",
              "prompt": "Что возвращает оператор keyof?",
              "options": [
                "Объединение строковых/числовых литералов с именами свойств типа.",
                "Количество полей в типе.",
                "Тип значений свойств.",
                "Ничего, он используется только в tsconfig."
              ],
              "answer": "Объединение строковых/числовых литералов с именами свойств типа.",
              "xp": 10,
              "tip": "keyof User даст 'id' | 'name' и т.д."
            },
            {
              "id": "transform-meta-7",
              "type": "fill",
              "prompt": "type FormKeys = ____ Form;",
              "placeholder": "оператор",
              "answers": [
                "keyof"
              ],
              "xp": 10,
              "tip": "Так получаем список допустимых ключей."
            },
            {
              "id": "transform-meta-8",
              "type": "choice",
              "prompt": "Как получить тип элемента массива tags, объявленного как const tags = ['row', 'col'] as const;?",
              "options": [
                "type Tag = typeof tags[number];",
                "type Tag = typeof tags;",
                "type Tag = keyof typeof tags;",
                "type Tag = tags[0];"
              ],
              "answer": "type Tag = typeof tags[number];",
              "xp": 10,
              "tip": "Индекс number по массиву типа readonly возвращает объединение литералов."
            },
            {
              "id": "transform-meta-9",
              "type": "select-line",
              "prompt": "На какой строке указано недопустимое значение для keyof?",
              "lines": [
                "interface User { id: string; name: string; }",
                "const key: keyof User = 'age';"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Возраст не входит в список ключей интерфейса.",
              "explanation": "keyof User даёт 'id' | 'name'."
            },
            {
              "id": "transform-meta-10",
              "type": "order",
              "prompt": "Расставь шаги при построении типа из объекта-константы.",
              "tokens": [
                "объявить const объект",
                "применить typeof к объекту",
                "взять keyof от полученного типа",
                "использовать результат в коде"
              ],
              "solution": [
                "объявить const объект",
                "применить typeof к объекту",
                "взять keyof от полученного типа",
                "использовать результат в коде"
              ],
              "xp": 12,
              "tip": "Часто нужен pipeline const ➜ typeof ➜ keyof."
            }
          ]
        }
      ]
    },
    {
      "id": "unit-narrowing-basics",
      "title": "Основы narrowing",
      "description": "Как сужать union-типы с помощью стандартных проверок и работать с discriminated unions.",
      "accent": "#F43F5E",
      "levels": [
        {
          "id": "lvl-narrowing-basics",
          "title": "Техники сужения типов",
          "goal": "Освоить стандартные проверки (typeof, instanceof, in, truthy) для безопасной работы с union-типами.",
          "steps": [
            {
              "id": "narrowing-basics-1",
              "type": "choice",
              "prompt": "Что такое narrowing (сужение) в TypeScript?",
              "options": [
                "Процесс уточнения union-типа на основании проверок в коде.",
                "Оптимизация размера бандла.",
                "Автоматическое форматирование кода.",
                "Специальный синтаксис для классов."
              ],
              "answer": "Процесс уточнения union-типа на основании проверок в коде.",
              "xp": 10,
              "tip": "Компилятор анализирует условия и сужает возможные варианты типа."
            },
            {
              "id": "narrowing-basics-2",
              "type": "select-line",
              "prompt": "На какой строке нужно добавить проверку типа?",
              "lines": [
                "function print(value: string | number) {",
                "  console.log(value.toUpperCase());",
                "}"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Метод toUpperCase доступен только строкам.",
              "explanation": "Нужно проверить typeof value === 'string' перед вызовом метода."
            },
            {
              "id": "narrowing-basics-3",
              "type": "match",
              "prompt": "Сопоставь проверку с тем, что она сужает.",
              "left": [
                "typeof value === 'string'",
                "value instanceof Date",
                "'id' in value",
                "Array.isArray(value)"
              ],
              "right": [
                "значение — строка",
                "значение — экземпляр Date",
                "объект содержит поле id",
                "значение — массив"
              ],
              "pairs": [
                {
                  "left": "typeof value === 'string'",
                  "right": "значение — строка"
                },
                {
                  "left": "value instanceof Date",
                  "right": "значение — экземпляр Date"
                },
                {
                  "left": "'id' in value",
                  "right": "объект содержит поле id"
                },
                {
                  "left": "Array.isArray(value)",
                  "right": "значение — массив"
                }
              ],
              "xp": 14,
              "tip": "Разные проверки подходят для разных структур."
            },
            {
              "id": "narrowing-basics-4",
              "type": "fill",
              "prompt": "После проверки typeof value === 'string' компилятор считает value ____.",
              "placeholder": "тип",
              "answers": [
                "string",
                "строкой"
              ],
              "xp": 10,
              "tip": "Внутри ветки можно вызывать string-методы без ошибок."
            },
            {
              "id": "narrowing-basics-5",
              "type": "choice",
              "prompt": "Как лучше всего обработать discriminated union?",
              "options": [
                "Сравнить значение поля tag/kind и разбить код на ветки.",
                "Всегда приводить тип к any.",
                "Использовать глобальную переменную для хранения текущего варианта.",
                "Объявить отдельный класс для каждого варианта."
              ],
              "answer": "Сравнить значение поля tag/kind и разбить код на ветки.",
              "xp": 10,
              "tip": "Одинаковое поле-дискриминатор делает ветви взаимоисключающими."
            },
            {
              "id": "narrowing-basics-6",
              "type": "select-line",
              "prompt": "На какой строке нужно проверить значение на null/undefined?",
              "lines": [
                "function printLength(text?: string) {",
                "  console.log(text.length);",
                "}"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Перед обращением к необязательному параметру требуется проверка truthy.",
              "explanation": "text может быть undefined, поэтому обращение к length небезопасно."
            },
            {
              "id": "narrowing-basics-7",
              "type": "choice",
              "prompt": "Что делает оператор in при сужении типов?",
              "options": [
                "Проверяет наличие свойства и тем самым подтверждает форму объекта.",
                "Удаляет свойство из объекта.",
                "Создаёт новый объект с нужным полем.",
                "Всегда возвращает true."
              ],
              "answer": "Проверяет наличие свойства и тем самым подтверждает форму объекта.",
              "xp": 10,
              "tip": "'key' in value работает даже для значений типа unknown."
            },
            {
              "id": "narrowing-basics-8",
              "type": "fill",
              "prompt": "Чтобы проверить, является ли значение массивом, используй ____.",
              "placeholder": "функцию",
              "answers": [
                "Array.isArray"
              ],
              "xp": 10,
              "tip": "Array.isArray(value) сужает тип до массива."
            },
            {
              "id": "narrowing-basics-9",
              "type": "choice",
              "prompt": "Что произойдёт с типом value после ветки if (!value) return; при типе string | undefined?",
              "options": [
                "Дальше в коде value рассматривается как string.",
                "Тип остаётся string | undefined.",
                "Тип становится never.",
                "Тип превращается в any."
              ],
              "answer": "Дальше в коде value рассматривается как string.",
              "xp": 10,
              "tip": "Проверка truthy устраняет undefined/falsey ветку."
            },
            {
              "id": "narrowing-basics-10",
              "type": "order",
              "prompt": "Расставь шаги при сужении объединения.",
              "tokens": [
                "определить потенциальные варианты типа",
                "написать проверку (typeof/in/instanceof)",
                "обработать ветку с уточнённым типом",
                "обработать оставшиеся варианты"
              ],
              "solution": [
                "определить потенциальные варианты типа",
                "написать проверку (typeof/in/instanceof)",
                "обработать ветку с уточнённым типом",
                "обработать оставшиеся варианты"
              ],
              "xp": 12,
              "tip": "Всегда покрывай все варианты union-типа."
            }
          ]
        },
        {
          "id": "lvl-type-guards",
          "title": "Пользовательские type guards",
          "goal": "Научиться писать функции-предикаты вида value is Type и применять их в коде.",
          "steps": [
            {
              "id": "type-guards-1",
              "type": "choice",
              "prompt": "Что возвращает пользовательский type guard?",
              "options": [
                "Булево значение с предикатом value is Type в сигнатуре.",
                "Строку с названием типа.",
                "Любое значение, главное — truthy.",
                "Promise<boolean>."
              ],
              "answer": "Булево значение с предикатом value is Type в сигнатуре.",
              "xp": 10,
              "tip": "Тип возвращаемого значения должен быть вида value is SomeType."
            },
            {
              "id": "type-guards-2",
              "type": "select-line",
              "prompt": "На какой строке guard объявлен некорректно?",
              "lines": [
                "function isUser(value: unknown): boolean {",
                "  return typeof value === 'object' && value !== null && 'name' in value;",
                "}"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Нужно вернуть value is User, чтобы сужение работало.",
              "explanation": "Без предиката TypeScript не поймёт, что функция уточняет тип."
            },
            {
              "id": "type-guards-3",
              "type": "fill",
              "prompt": "Допиши сигнатуру: function isUser(value: unknown): value is ____ { return typeof (value as any)?.name === 'string'; }",
              "placeholder": "тип",
              "answers": [
                "User"
              ],
              "xp": 10,
              "tip": "Имя типа после is определяет, к чему сузится переменная внутри if."
            },
            {
              "id": "type-guards-4",
              "type": "match",
              "prompt": "Сопоставь guard с тем, что он проверяет.",
              "left": [
                "function isDate(value: unknown): value is Date { return value instanceof Date; }",
                "function hasId(value: any): value is { id: string } { return !!value && typeof value.id === 'string'; }",
                "function isPromise<T>(value: any): value is Promise<T> { return typeof value?.then === 'function'; }"
              ],
              "right": [
                "значение — Date",
                "объект имеет строковый id",
                "значение — промис"
              ],
              "pairs": [
                {
                  "left": "function isDate(value: unknown): value is Date { return value instanceof Date; }",
                  "right": "значение — Date"
                },
                {
                  "left": "function hasId(value: any): value is { id: string } { return !!value && typeof value.id === 'string'; }",
                  "right": "объект имеет строковый id"
                },
                {
                  "left": "function isPromise<T>(value: any): value is Promise<T> { return typeof value?.then === 'function'; }",
                  "right": "значение — промис"
                }
              ],
              "xp": 14,
              "tip": "Гвард должен возвращать строгую проверку."
            },
            {
              "id": "type-guards-5",
              "type": "choice",
              "prompt": "Где использовать type guard?",
              "options": [
                "В условном операторе (if/while) для сужения типа внутри ветки.",
                "Только при объявлении типов, но не в коде.",
                "Только в tsconfig.",
                "Гварды работают лишь внутри классов."
              ],
              "answer": "В условном операторе (if/while) для сужения типа внутри ветки.",
              "xp": 10,
              "tip": "После вызова guard-а в условии переменная получает более точный тип."
            },
            {
              "id": "type-guards-6",
              "type": "select-line",
              "prompt": "На какой строке неверно используется возвращаемое значение guard-а?",
              "lines": [
                "function isString(value: unknown): value is string {",
                "  return typeof value === 'string';",
                "}",
                "const data: string | number = Math.random() > 0.5 ? 'hi' : 42;",
                "if (isString(data)) {",
                "  console.log(data.toFixed(2));",
                "}"
              ],
              "answerLine": 6,
              "xp": 12,
              "tip": "После подтверждения типа string нужно использовать string-методы.",
              "explanation": "toFixed доступен числам, а не строкам."
            },
            {
              "id": "type-guards-7",
              "type": "fill",
              "prompt": "После вызова guard-а переменная внутри ветки рассматривается как ____ тип.",
              "placeholder": "какой?",
              "answers": [
                "уточнённый",
                "узкий"
              ],
              "xp": 10,
              "tip": "Guard фиксирует конкретный тип вместо объединения."
            },
            {
              "id": "type-guards-8",
              "type": "choice",
              "prompt": "Может ли type guard быть методом класса?",
              "options": [
                "Да, если метод возвращает this is SomeType или value is SomeType.",
                "Нет, гварды разрешены только в функциях верхнего уровня.",
                "Только в абстрактных классах.",
                "Только если класс объявлен в файле .d.ts."
              ],
              "answer": "Да, если метод возвращает this is SomeType или value is SomeType.",
              "xp": 10,
              "tip": "Guard работает везде, где допустима сигнатура с is."
            },
            {
              "id": "type-guards-9",
              "type": "order",
              "prompt": "Расставь шаги при создании пользовательского type guard.",
              "tokens": [
                "описать целевой тип",
                "написать функцию с сигнатурой value is Type",
                "настроить проверку внутри",
                "использовать guard в условии"
              ],
              "solution": [
                "описать целевой тип",
                "написать функцию с сигнатурой value is Type",
                "настроить проверку внутри",
                "использовать guard в условии"
              ],
              "xp": 12,
              "tip": "Главное — вернуть корректный предикат."
            },
            {
              "id": "type-guards-10",
              "type": "choice",
              "prompt": "Почему type guard должен быть чистым (идемпотентным)?",
              "options": [
                "Результат проверки должен зависеть только от аргумента, иначе трудно понять, какой тип получим.",
                "Потому что TypeScript запрещает side effects.",
                "Иначе guard не скомпилируется.",
                "Чистота функции ускоряет выполнение кода."
              ],
              "answer": "Результат проверки должен зависеть только от аргумента, иначе трудно понять, какой тип получим.",
              "xp": 10,
              "tip": "Гвард используется как логическое условие, поэтому его поведение должно быть предсказуемым."
            }
          ]
        }
      ]
    },
    {
      "id": "unit-operators",
      "title": "TS-операторы",
      "description": "Optional chaining, nullish coalescing и non-null assertion.",
      "accent": "#0D9488",
      "levels": [
        {
          "id": "lvl-optional-nonnull",
          "title": "Optional chaining и !",
          "goal": "Использовать ?. и ?? вместо вложенных проверок и понимать риски non-null assertion.",
          "steps": [
            {
              "id": "operators-optional-1",
              "type": "choice",
              "prompt": "Что делает оператор optional chaining (?.)?",
              "options": [
                "Останавливает доступ к свойству, если промежуточное значение равно null/undefined.",
                "Удаляет свойство из объекта.",
                "Создаёт глубокую копию объекта.",
                "Работает только в браузере."
              ],
              "answer": "Останавливает доступ к свойству, если промежуточное значение равно null/undefined.",
              "xp": 10,
              "tip": "user?.address вернёт undefined, если address отсутствует."
            },
            {
              "id": "operators-optional-2",
              "type": "select-line",
              "prompt": "На какой строке следует заменить доступ на optional chaining?",
              "lines": [
                "const city = user.address.city;",
                "console.log(city);"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Если address может отсутствовать, используйте user.address?.city.",
              "explanation": "Без ?. выражение упадёт при address === null."
            },
            {
              "id": "operators-optional-3",
              "type": "choice",
              "prompt": "Чем ?. отличается от последовательности &&?",
              "options": [
                "?. возвращает undefined без потери значения, тогда как && возвращает первое ложное значение.",
                "&& работает быстрее.",
                "?. не поддерживается TypeScript.",
                "&& выбрасывает исключение при null."
              ],
              "answer": "?. возвращает undefined без потери значения, тогда как && возвращает первое ложное значение.",
              "xp": 10,
              "tip": "Optional chaining предназначен специально для проверки на null/undefined."
            },
            {
              "id": "operators-optional-4",
              "type": "fill",
              "prompt": "Заполни выражение: const city = user.address?.city ____ 'unknown';",
              "placeholder": "оператор",
              "answers": [
                "??"
              ],
              "xp": 10,
              "tip": "?? подставляет значение только если слева null/undefined."
            },
            {
              "id": "operators-optional-5",
              "type": "match",
              "prompt": "Сопоставь конструкцию с кейсом использования.",
              "left": [
                "user?.profile",
                "settings?.theme ?? 'light'",
                "listener?.(event)",
                "dict?.[key]"
              ],
              "right": [
                "доступ к вложенному объекту",
                "значение по умолчанию при отсутствии настроек",
                "вызов необязательной функции",
                "чтение динамического ключа"
              ],
              "pairs": [
                {
                  "left": "user?.profile",
                  "right": "доступ к вложенному объекту"
                },
                {
                  "left": "settings?.theme ?? 'light'",
                  "right": "значение по умолчанию при отсутствии настроек"
                },
                {
                  "left": "listener?.(event)",
                  "right": "вызов необязательной функции"
                },
                {
                  "left": "dict?.[key]",
                  "right": "чтение динамического ключа"
                }
              ],
              "xp": 14,
              "tip": "Optional chaining работает для доступа, вызова и индексации."
            },
            {
              "id": "operators-optional-6",
              "type": "choice",
              "prompt": "Что делает non-null assertion (!) после выражения?",
              "options": [
                "Сообщает компилятору, что значение точно не null/undefined.",
                "Удаляет значение.",
                "Записывает undefined.",
                "Преобразует значение в boolean."
              ],
              "answer": "Сообщает компилятору, что значение точно не null/undefined.",
              "xp": 10,
              "tip": "button!.addEventListener(...) — ответственность за корректность на разработчике."
            },
            {
              "id": "operators-optional-7",
              "type": "select-line",
              "prompt": "На какой строке non-null assertion применяется небезопасно?",
              "lines": [
                "const maybeUser: User | null = Math.random() > 0.5 ? user : null;",
                "console.log(maybeUser!.name);"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Если значение реально может быть null, лучше добавить проверку.",
              "explanation": "При maybeUser === null обращение к name приведёт к ошибке."
            },
            {
              "id": "operators-optional-8",
              "type": "fill",
              "prompt": "const button = document.querySelector('#save'); button___.addEventListener('click', save);",
              "placeholder": "оператор",
              "answers": [
                "!"
              ],
              "xp": 10,
              "tip": "! указывает, что элемент точно найден (используй только если это гарантировано)."
            },
            {
              "id": "operators-optional-9",
              "type": "choice",
              "prompt": "Для чего используют синтаксис listener?.(event)?",
              "options": [
                "Чтобы вызвать функцию только если она определена.",
                "Чтобы превратить значение в промис.",
                "Чтобы объявить перегрузку функции.",
                "Чтобы клонировать event."
              ],
              "answer": "Чтобы вызвать функцию только если она определена.",
              "xp": 10,
              "tip": "?.() безопасно вызывает необязательный callback."
            },
            {
              "id": "operators-optional-10",
              "type": "order",
              "prompt": "Собери выражение, которое логирует имя пользователя или 'anon'.",
              "tokens": [
                "console.log(",
                "user",
                "?.",
                "name",
                "??",
                "'anon'",
                ")"
              ],
              "solution": [
                "console.log(",
                "user",
                "?.",
                "name",
                "??",
                "'anon'",
                ")"
              ],
              "xp": 12,
              "tip": "Часто ?. комбинируют с ?? для значений по умолчанию."
            }
          ]
        }
      ]
    },
    {
      "id": "unit-enums",
      "title": "Перечисления",
      "description": "enum, const enum и сравнение с обычными объектами.",
      "accent": "#F59E0B",
      "levels": [
        {
          "id": "lvl-enums-core",
          "title": "Работа с enum",
          "goal": "Создавать и использовать enum/const enum, понимать различия с объектами.",
          "steps": [
            {
              "id": "enums-1",
              "type": "choice",
              "prompt": "Что такое enum в TypeScript?",
              "options": [
                "Сгенерированный объект, описывающий набор именованных констант.",
                "Специальный тип данных из JavaScript.",
                "Функция для округления чисел.",
                "Расширение синтаксиса JSON."
              ],
              "answer": "Сгенерированный объект, описывающий набор именованных констант.",
              "xp": 10,
              "tip": "enum компилируется в JS-объект (кроме const enum)."
            },
            {
              "id": "enums-2",
              "type": "choice",
              "prompt": "Чем const enum отличается от обычного enum?",
              "options": [
                "Значения const enum подставляются прямо в код и объект не создаётся.",
                "const enum доступен только в Node.js.",
                "Разницы нет.",
                "const enum работает только с числами."
              ],
              "answer": "Значения const enum подставляются прямо в код и объект не создаётся.",
              "xp": 10,
              "tip": "const enum исчезает после компиляции, оставляя только литеральные значения."
            },
            {
              "id": "enums-3",
              "type": "select-line",
              "prompt": "На какой строке присваивается значение, отсутствующее в enum?",
              "lines": [
                "enum Status { Ready = 0, Done = 1 }",
                "const status: Status = 2;"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Enum допускает только объявленные значения.",
              "explanation": "Число 2 не принадлежит enum Status."
            },
            {
              "id": "enums-4",
              "type": "match",
              "prompt": "Сопоставь конструкцию с её поведением.",
              "left": [
                "enum",
                "const enum",
                "Literal object + type"
              ],
              "right": [
                "создаёт JS-объект и поддерживает обратные маппинги (для numeric)",
                "инлайнит значения, объект не создаётся",
                "не генерирует спец.кода, но требует ручного типа"
              ],
              "pairs": [
                {
                  "left": "enum",
                  "right": "создаёт JS-объект и поддерживает обратные маппинги (для numeric)"
                },
                {
                  "left": "const enum",
                  "right": "инлайнит значения, объект не создаётся"
                },
                {
                  "left": "Literal object + type",
                  "right": "не генерирует спец.кода, но требует ручного типа"
                }
              ],
              "xp": 14,
              "tip": "Выбор зависит от требований к рантайму и типам."
            },
            {
              "id": "enums-5",
              "type": "fill",
              "prompt": "enum Direction { Up = 'up', Down = ____ }",
              "placeholder": "значение",
              "answers": [
                "'down'",
                "\"down\""
              ],
              "xp": 10,
              "tip": "Строковые enum требуют явных значений для каждого поля."
            },
            {
              "id": "enums-6",
              "type": "choice",
              "prompt": "Что произойдёт при обращении Status[Status.Ready] для числового enum?",
              "options": [
                "Вернётся имя 'Ready'.",
                "Вернётся undefined.",
                "Будет ошибка компиляции.",
                "Вернётся число 0."
              ],
              "answer": "Вернётся имя 'Ready'.",
              "xp": 10,
              "tip": "Числовые enum имеют обратные маппинги. Строковые — нет."
            },
            {
              "id": "enums-7",
              "type": "choice",
              "prompt": "Почему иногда вместо enum выбирают объект + type?",
              "options": [
                "Чтобы избежать лишнего кода в бандле и лучше работать с tree-shaking.",
                "Потому что enum запрещены в strict режиме.",
                "Потому что enum не поддерживаются в VS Code.",
                "Потому что объект быстрее работает в рантайме."
              ],
              "answer": "Чтобы избежать лишнего кода в бандле и лучше работать с tree-shaking.",
              "xp": 10,
              "tip": "Объект + типовой union не генерирует вспомогательных конструкций."
            },
            {
              "id": "enums-8",
              "type": "select-line",
              "prompt": "На какой строке незаконно итерироваться по const enum?",
              "lines": [
                "const enum Flags { A = 1, B = 2 }",
                "const keys = Object.keys(Flags);"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "const enum исчезает после компиляции, поэтому объекта для Object.keys нет.",
              "explanation": "Чтобы получить список значений, используй обычный enum или массив."
            },
            {
              "id": "enums-9",
              "type": "fill",
              "prompt": "type StatusName = ____ Status; // имена членов",
              "placeholder": "операторы",
              "answers": [
                "keyof typeof"
              ],
              "xp": 10,
              "tip": "Комбинация keyof typeof возвращает union имён enum."
            },
            {
              "id": "enums-10",
              "type": "order",
              "prompt": "Собери шаги для создания enum через объект.",
              "tokens": [
                "объявить const объект",
                "добавить as const",
                "получить тип значений через typeof obj[keyof typeof obj]",
                "использовать тип в коде"
              ],
              "solution": [
                "объявить const объект",
                "добавить as const",
                "получить тип значений через typeof obj[keyof typeof obj]",
                "использовать тип в коде"
              ],
              "xp": 12,
              "tip": "Подход удобен, когда не хочется генерировать enum в рантайме."
            }
          ]
        }
      ]
    },
    {
      "id": "unit-utilities",
      "title": "Utility types",
      "description": "Mapped types, модификаторы и стандартные утилиты вроде Partial/Pick/ReturnType.",
      "accent": "#8B5CF6",
      "levels": [
        {
          "id": "lvl-utilities-mapped",
          "title": "Mapped types",
          "goal": "Понять синтаксис {[K in keyof T]}, модификаторы и ремап ключей.",
          "steps": [
            {
              "id": "utilities-mapped-1",
              "type": "choice",
              "prompt": "Что делает шаблон { [K in keyof T]: T[K] }?",
              "options": [
                "Создаёт новый тип, копирующий все свойства T.",
                "Удаляет все свойства из T.",
                "Преобразует T в массив.",
                "Эта запись невалидна."
              ],
              "answer": "Создаёт новый тип, копирующий все свойства T.",
              "xp": 10,
              "tip": "Mapped type проходит по каждому ключу исходного типа."
            },
            {
              "id": "utilities-mapped-2",
              "type": "select-line",
              "prompt": "На какой строке пропущено ключевое слово in?",
              "lines": [
                "type Nullable<T> = {",
                "  [K keyof T]: T[K] | null;",
                "};"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Синтаксис требует [K in keyof T].",
              "explanation": "Без in mapped type не скомпилируется."
            },
            {
              "id": "utilities-mapped-3",
              "type": "fill",
              "prompt": "Заполни модификатор, чтобы сделать свойства опциональными: type Optional<T> = { [K in keyof T]__ T[K]; }",
              "placeholder": "символы",
              "answers": [
                "?:",
                "? :"
              ],
              "xp": 10,
              "tip": "? добавляет необязательность конкретному ключу."
            },
            {
              "id": "utilities-mapped-4",
              "type": "match",
              "prompt": "Сопоставь модификатор с его эффектом.",
              "left": [
                "+readonly",
                "-readonly",
                "+?",
                "-?"
              ],
              "right": [
                "делает поле неизменяемым",
                "снимает readonly",
                "делает поле опциональным",
                "делает поле обязательным"
              ],
              "pairs": [
                {
                  "left": "+readonly",
                  "right": "делает поле неизменяемым"
                },
                {
                  "left": "-readonly",
                  "right": "снимает readonly"
                },
                {
                  "left": "+?",
                  "right": "делает поле опциональным"
                },
                {
                  "left": "-?",
                  "right": "делает поле обязательным"
                }
              ],
              "xp": 14,
              "tip": "Плюсы добавляют, минусы снимают модификаторы."
            },
            {
              "id": "utilities-mapped-5",
              "type": "choice",
              "prompt": "Как исключить ключи, начинающиеся с '_'?",
              "options": [
                "Использовать remap: [K in keyof T as K extends `_${string}` ? never : K]",
                "Просто объявить интерфейс без этих ключей.",
                "Mapped types не умеют исключать ключи.",
                "Поставить оператор delete в типе."
              ],
              "answer": "Использовать remap: [K in keyof T as K extends `_${string}` ? never : K]",
              "xp": 12,
              "tip": "Выражение после as позволяет изменить имя ключа или выкинуть его через never."
            },
            {
              "id": "utilities-mapped-6",
              "type": "select-line",
              "prompt": "Где отсутствует as при ремапе ключей?",
              "lines": [
                "type RemovePrivate<T> = {",
                "  [K in keyof T extends `_${string}` ? never : K]: T[K];",
                "};"
              ],
              "answerLine": 2,
              "xp": 12,
              "tip": "Условие должно идти после as: [K in keyof T as ...].",
              "explanation": "Без as условие применяется к самому K in, а не к имени ключа."
            },
            {
              "id": "utilities-mapped-7",
              "type": "fill",
              "prompt": "Допиши модификатор: type Mutable<T> = { ____ [K in keyof T]: T[K] };",
              "placeholder": "модификатор",
              "answers": [
                "-readonly"
              ],
              "xp": 10,
              "tip": "Минус перед readonly убирает ограничение."
            },
            {
              "id": "utilities-mapped-8",
              "type": "choice",
              "prompt": "Зачем в mapped type используют keyof T?",
              "options": [
                "Чтобы итерироваться по всем ключам входного типа.",
                "Чтобы получить значения полей.",
                "Чтобы обратиться к прототипу объекта.",
                "Чтобы вызвать функцию."
              ],
              "answer": "Чтобы итерироваться по всем ключам входного типа.",
              "xp": 10,
              "tip": "keyof T даёт union строк/символов, по которому строится mapped type."
            },
            {
              "id": "utilities-mapped-9",
              "type": "order",
              "prompt": "Расставь шаги создания mapped type с фильтрацией ключей.",
              "tokens": [
                "взять keyof T",
                "описать новый ключ K",
                "добавить as с условием",
                "указать значение T[K] с модификатором"
              ],
              "solution": [
                "взять keyof T",
                "описать новый ключ K",
                "добавить as с условием",
                "указать значение T[K] с модификатором"
              ],
              "xp": 12,
              "tip": "Ключи можно трансформировать прежде чем вернуть их наружу."
            },
            {
              "id": "utilities-mapped-10",
              "type": "choice",
              "prompt": "Что происходит с ключом, если выражение после as возвращает never?",
              "options": [
                "Ключ удаляется из результирующего типа.",
                "Ключ становится optional.",
                "Ключ получает значение undefined.",
                "Происходит ошибка компиляции."
              ],
              "answer": "Ключ удаляется из результирующего типа.",
              "xp": 10,
              "tip": "never в имени ключа — способ фильтровать свойства."
            }
          ]
        },
        {
          "id": "lvl-utilities-builtins",
          "title": "Стандартные утилиты",
          "goal": "Использовать Partial/Required/Readonly/Pick/Omit/Record, а также ReturnType/Parameters/Awaited.",
          "steps": [
            {
              "id": "utilities-builtins-1",
              "type": "choice",
              "prompt": "Что делает Partial<T>?",
              "options": [
                "Помечает все свойства T как необязательные.",
                "Удаляет все свойства из T.",
                "Делает все свойства readonly.",
                "Превращает T в массив."
              ],
              "answer": "Помечает все свойства T как необязательные.",
              "xp": 10,
              "tip": "Partial — простой mapped type с ? для каждого ключа."
            },
            {
              "id": "utilities-builtins-2",
              "type": "select-line",
              "prompt": "На какой строке нарушается Readonly?",
              "lines": [
                "type Config = Readonly<{ port: number }>;",
                "const cfg: Config = { port: 3000 };",
                "cfg.port = 4000;"
              ],
              "answerLine": 3,
              "xp": 12,
              "tip": "Readonly запрещает перезапись свойств."
            },
            {
              "id": "utilities-builtins-3",
              "type": "match",
              "prompt": "Сопоставь утилиту с её назначением.",
              "left": [
                "Pick<T, K>",
                "Omit<T, K>",
                "Record<K, V>",
                "ReturnType<F>"
              ],
              "right": [
                "берёт подмножество ключей",
                "исключает ключи",
                "создаёт объект со значениями одного типа",
                "извлекает тип возвращаемого значения функции"
              ],
              "pairs": [
                {
                  "left": "Pick<T, K>",
                  "right": "берёт подмножество ключей"
                },
                {
                  "left": "Omit<T, K>",
                  "right": "исключает ключи"
                },
                {
                  "left": "Record<K, V>",
                  "right": "создаёт объект со значениями одного типа"
                },
                {
                  "left": "ReturnType<F>",
                  "right": "извлекает тип возвращаемого значения функции"
                }
              ],
              "xp": 14,
              "tip": "Эти утилиты часто комбинируют между собой."
            },
            {
              "id": "utilities-builtins-4",
              "type": "fill",
              "prompt": "Сделай все поля обязательными: type RequiredUser = ____<User>;",
              "placeholder": "утилита",
              "answers": [
                "Required"
              ],
              "xp": 10,
              "tip": "Required снимает знак ?."
            },
            {
              "id": "utilities-builtins-5",
              "type": "choice",
              "prompt": "Когда удобнее всего применять Record<K, V>?",
              "options": [
                "Когда нужен словарь с заранее известным union ключей.",
                "Чтобы описать массив.",
                "Чтобы типизировать класс.",
                "Record работает только с Map."
              ],
              "answer": "Когда нужен словарь с заранее известным union ключей.",
              "xp": 10,
              "tip": "Record полезен для объектных таблиц значений."
            },
            {
              "id": "utilities-builtins-6",
              "type": "select-line",
              "prompt": "Где неправильно указан первый параметр Record?",
              "lines": [
                "type Flags = Record<['read', 'write'], boolean>;",
                "const flags: Flags = { read: true, write: false };"
              ],
              "answerLine": 1,
              "xp": 12,
              "tip": "Первый аргумент Record — union ключей, а не массив.",
              "explanation": "Нужно Record<'read' | 'write', boolean>."
            },
            {
              "id": "utilities-builtins-7",
              "type": "fill",
              "prompt": "Убери null/undefined: type Mode = ____<string | null | undefined>;",
              "placeholder": "утилита",
              "answers": [
                "NonNullable"
              ],
              "xp": 10,
              "tip": "NonNullable фильтрует null и undefined."
            },
            {
              "id": "utilities-builtins-8",
              "type": "choice",
              "prompt": "Как получить тип результата вызова makeQuery?",
              "options": [
                "ReturnType<typeof makeQuery>",
                "typeof makeQuery",
                "Parameters<typeof makeQuery>",
                "InstanceType<typeof makeQuery>"
              ],
              "answer": "ReturnType<typeof makeQuery>",
              "xp": 10,
              "tip": "ReturnType извлекает тип из сигнатуры функции."
            },
            {
              "id": "utilities-builtins-9",
              "type": "select-line",
              "prompt": "На какой строке неверно используется Parameters?",
              "lines": [
                "function handle(event: MouseEvent, options?: { stop: boolean }) {}",
                "type EventArg = Parameters<typeof handle>[0];",
                "type OptionsArg = Parameters<typeof handle>[2];"
              ],
              "answerLine": 3,
              "xp": 12,
              "tip": "Parameters возвращает кортеж, индексы нужно держать в диапазоне.",
              "explanation": "У функции всего два параметра, индекс 2 недоступен."
            },
            {
              "id": "utilities-builtins-10",
              "type": "order",
              "prompt": "Собери выражение, извлекающее резолв типа промиса из функции fetchData.",
              "tokens": [
                "Awaited<",
                "ReturnType<",
                "typeof fetchData",
                ">",
                ">"
              ],
              "solution": [
                "Awaited<",
                "ReturnType<",
                "typeof fetchData",
                ">",
                ">"
              ],
              "xp": 12,
              "tip": "Awaited применяют поверх ReturnType, чтобы добраться до внутреннего значения промиса."
            }
          ]
        }
      ]
    }
  ]
}
